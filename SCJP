Boxing
	* Boolean, Byte, Character from \u0000 to \u007f (127), Short and Integer from -128 to 127 They are be =
	
		Integer i1 = 10;
		Integer i2 = 10;
		i1 == i2; // True
		
		Integer i1 = 128;
		Integer i2 = 128;
		i1 == i2; // False because > 127 but equals True
	 
	 * Оболочные классы не могут быть расширены Bytes не может быть раширен до Short e.t.c
	 * При overloading и autoboxing если просходит раширение до типа то проверяется IS-A
	
	 	class WidenAndBox {
	 		static void go(Long x) { System.out.println("Long"); }
            
            public static void main(String [] args) {
                    byte b = 5;
                    go(b); // must widen then box - illegal
			} 
		}
	
	* Here's a review of the rules for overloading methods using widening, boxing, and var-args:
		■ Primitive widening uses the "smallest" method argument possible.
		■ Used individually, boxing and var-args are compatible with overloading.
		■ You CANNOT widen from one wrapper type to another. (IS-A fails.)
		■ You CANNOT widen and then box. (An int can't become a Long.)
		■ You can box and then widen. (An int can become an Object, via Integer.)
		■ You can combine var-args with either widening or boxing.
	
	* такое возможно int[][] a = {{1,2,}, {3,4}};
	
Operators
	* операторы += *= делают cast
	
	* операторы *= *= работают на выражением справа
		int a *= 3 - 2
		 Это не a = 3*a - 
		 Это не a = a*(3-2)
		 
	* instanceof null всегда false
	
	* непрямая проверка instanceof true если супер класс имплеметирует интерфейс то и потомки неявно его имплеметирует
		interface Foo { }
		class A implements Foo { }
		class B extends A { }
		...
		A a = new A();
		B b = new B();
		
	  the following are true:
		a instanceof Foo
		b instanceof A
		b instanceof Foo // implemented indirectly
		
	* Нельзя проверять через instanceof 2 разные иерархии классов это Compilation Error
		class Cat { }
		class Dog {
			public static void main(String [] args) {
				Dog d = new Dog();
				System.out.println(d instanceof Cat);
			}
		}
	
	* Массивы это объекты они проверяются True
		if (nums instanceof Object) { } // result is true
	
	* операторы * , / и % имеют приоритет выше чем + и -
	
	* скобки имеют приоритет
	
	* При конкотенации строки если поставить скобки то будет вычисляться результат
		String a = "String";
		int b = 3;
		int c = 7;
		System.out.println(a + (b + c)); // Result is String37
		System.out.println(a + (b + c)); // Result is String10
		
	* Если слева строка производится конкатенация
		String s = "123";
		s += "45";
		s += 67;
		System.out.println(s); //1234567
	
	* инкрементное значение i++ - сначала присваивается потом увеличивается
	
	* Быть осторожным с ++ -- для final переменых
		final int x = 5;
		int y = x++;
		//and produces the error:
		Test.java:4: cannot assign a value to final variable x
		int y = x++;
				^
	
	* && and || используются только с булевыми операндами
		if (5 && 6) { } // Compilation error потому что 5 и 6 int
	
	* & и | - вычисляют обе части
	
	* ^ - вычисляет обе части. Если оба операнда одинаковые то значение false

Flow, Control, Exceptions, Assertions
	* УПС
		int y = 5;
		int x = 2;
		if ((x > 3) && (y < 2) | doStuff()) //Не напечатает так как используется короткая схема
		
		if (((x > 3) && (y < 2)) | doStuff()) //Все ок 2я часть вычисляется всегда и все ОК 
		{
			System.out.println("true"); //Не напечатает так как используется короткая схема
			}
		}

		static boolean doStuff() {
			return true;
		}
	
	* в if присвоение возможно только для Boolean и boolean, остальное compilation error
		boolean boo = false;
		if (boo = true) { } //Все ок даже присвоение проходит
		
		int x = 3;
		if (x = 5) { } // Won't compile because x is not a boolean!
		
	* switch проверяет char, byte, short, int, enum 
	* в switch cast возможен
	
	* в метках switch можно использовать final переменные
		final short s =1;	
		int i = 1;
		
		switch (s) {
			case s:		All OK
				break;
		}
		
		//But,
		final short s;
		s =1;			
		int i = 1;
		
		switch (s) {
			case s:		//Compile error
				break;
		}
		
	* Одинаковые имена меток это Compile error
	
	* Если в выражение switch передать значение ниже int например byte,
		 и в метке указать значение больше значения типа то будет ошибка компиляции
	
		byte g = 2;
		switch(g) {
			case 23: 
			case 128: // 128 > разрешенных 127
		}
		
	* в switch case и : после метки обязательны
	
	* В switch char сравнивается как unicode
	
	* В switch при char работает и значение не unicode char и unicode char
				char c = '1';

		switch (c) {
			case 65535: //Legal last char
				System.out.println("1");
				break;

			case '\u0001': //Legal
				System.out.println("1"); 
				break;

			case 65536: 
				System.out.println("1"); //Compile error значение юольше разрешенного 65535 для char
				break;

			default:
				System.out.println("Default");
				break;
		}
		
		char c = '\u0001';
		
		switch (c) {
			case '\u0001':
				System.out.println("\u0001"); //Напечатается Юникод символ
				break;
		}

  Loops and Iterators (Exam Objective 2.2)
	* В блоке увеличения переменной может быть печать, анонимное создание класаса и т п
		int d = 3;
		for (int a = 1; d != 1; System.out.println("iterate")) {
			d = d - a;
		}

		int b = 3;
		for (int a = 1; b != 1; new String()) {
			b = b - a;
		}
		
		//Но
		int b = 3;
		for (int a = 1; b != 1; {new String()}) { // ошибка из за {}
			b = b - a;
		}
		
	* continue - используется только в циклах
	
	* break - используется в циклах и switch
	
	* Метка должна предворять цикл или иметь {} в случае наличия выражение перед ней
	
		label: //All OK 
			for (int i = 0; i < args.length; i++) {
				System.out.println("InLOOP");
				break label;
			}

		// Но ошибка если что то есть
		label: //Compile error
			System.out.println("Before Loop");
			for (int i = 0; i < args.length; i++) {
				System.out.println("InLOOP");
				break label;
			}
			
		// Но нет ошибки если есть {}
		label: { //OK
			System.out.println("Before Loop");
			for (int i = 0; i < args.length; i++) {
				System.out.println("InLOOP");
				break label;
			}
		}
		
Handling Exceptions (Exam Objectives 2.4 and 2.5)
	* Иерархия классов Exception
		Object
		  |
	   Throwable
	    |	   |
	 Error    ____Exception______
	 |		|					|
Others... RuntimeException	 Others... 

	* Если в коде выбрасывается исключение и оно checked то будет compile error
		
		//Fail IOException нужно задекларировать
		public void doStuff() {
			try {
				// risky IO things
			} catch(IOException ex) {
				// can't handle it
				throw ex; // Can't throw it unless you declare it
			}
		}
	
	* finally может не вызваться если в try или catch вызван System.exit()  
		
Common Exceptions and Errors (Exam Objective 2.6)
	*Throw JVM
		ArrayIndexOutOfBoundsException
		ClassCastException
		NullPointerException
		ExceptionInInitializerError
		StackOverflowError
		NoClassDefFoundError
	
	*throw Programmatically
		IllegalArgumentException
		IllegalStateException
		NumberFormatException
		AssertionError

Working with the Assertion Mechanism  (Exam Objective 2.3)
	*Валидное использование Assertion
		int x = 1;
		boolean b = true;
		int aReturn() { return 1; }
		
		assert(x == 1);
		assert(b);
		assert true;
		assert(x == 1) : x;
		assert(x == 1) : aReturn();
		assert(x == 1) : new ValidAssert();
		
	*Невалидное использование Assertion
		void noReturn() { }
		
		assert(x = 1); // none of these are booleans
		assert(x);
		assert 0;
		assert(x == 1) : ; // none of these return a value
		assert(x == 1) : noReturn();
		assert(x == 1) : ValidAssert va;
		
	* До версии 1.4 слово assert можно использовать как идентификатор
		int assert = getInitialValue();
		if (assert == getActualResult()) {
			// do something
		}
	  
	  Если использовать компиляцию для 1.6 будет ошибка, 
	  но можно сделать javac -source 1.3 OldCode.java - все ок хотя если использовать assert как ключевое слово то это ошибка
	  
	 * 2 опции для включения компиляторов 5,6 
	 	-source 1.6 or -source 6
	 	-source 1.5 or -source 5
	 
	 * Компиляция под разные версии JVM
	 	javac -source 1.3 TestAsserts.java
	 	javac -source 1.4 TestAsserts.java
	 	javac -source 1.5 TestAsserts.java
	 	javac -source 5 TestAsserts.java
	 	javac -source 1.6 TestAsserts.java
	 	javac -source 6 TestAsserts.java
	 
	 * Включение assertion в runtime
	 	java -ea com.pack.TestClass
	 	java -enableassertions com.pack.TestClass
	 	
	 * Выключение assertion в runtime
	 	java -da com.pack.TestClass
	 	java -disableassertions com.pack.TestClass
	 	
	 * Частичное исключение классов
	 	java -ea -da:com.geeksanonymous.Foo Test
	 	
	 * Частичное исключение пакетов
	 	java -ea -da:com.geeksanonymous...
	 	
	 * Tricky assertion
	 	java -ea -dsa Enable assertions in general, but disable assertions in system classes.

Using Assertions Appropriately (По конвеции Sun)
	 * Inappropriate использовать assertion для валидации аргументов в public методах
		 public void doMore(int x) {
			assert (x > 0);
			// do things with x
		}
	 * Inappropriate использовать assertion для валидации аргументов командной строки
	 * Inappropriate использовать assertion для изменения логики работы программы, при вызове assertion и без него логика остается таже
	 	public void doStuff() {
			assert (modifyThings());
			// continues on
		}
		
		public boolean modifyThings() {
			y = x++;
			return true;
		}
	 
	 * Appropriate использовать assertion для валидации аргументов в private методах
	 	private void doMore(int x) {
			assert (x > 0);
			// do things with x
		}
	
	* Appropriate использовать assertion для кода который точно никогда не выполнится даже в public методах
		switch(x) {
			case 1: y = 3; break;
			case 2: y = 9; break;
			case 3: y = 27; break;
			default: assert false; // we're never supposed to get here!
		}
	