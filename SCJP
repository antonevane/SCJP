Identifiers & JavaBeans (Objectives 1.3 and 1.4)
	* Идентификатор может быть любой длины
	
	* Может начинаться с '_', '$'
	
	* константы всегда final и static
	
	* в JavaBean нотации boolean может использовать 2 метода получения знаения
		getFeild()
		isField()

JavaBean Listener Naming Rules
	* метод использующийся для регистрации слушателя с источником события должен иметь префикс add следом тип события
		addActionListener()
		
	* Название методля для удаления слушателя должен начинаться с префикса remove следом тип события
		public void removeActionListener(ActionListener listener)
		
	* Тип слушателя который будет удаляться или добаляться должен передается как параметр
	
	* Имя метода слушателя должно оканчиваться словом Listener
		public void addMyListener(MyListener m)
		public void removeMyListener(MyListener m) 
		
Declare Classes (Exam Objective 1.1)
	* Source File Declaration Rules
		■  На файл может быть всего 1 public class
		■  Коментарии могут появляться в любом месте класса
		■  Имя файла с раширением class должно совпадать с именем public класса
		■  Если класс находится в пакете то имя пакета должно быть первым выражением в класса
		■  import должен идти между пакетои и именем класса. Если имени пакета нет то import идет первым выражением
		■  package и import применяются ко всему файлу
		■  В файле могут быть множество не final классов
		
	* Class Declarations and Modifiers
		■  Модификаторы доступа: public, protected, private
		■  Модификаторы не относящиеся к доступу: final, abstract, strictfp
		
	* Классу не обязательно быть public в файле т.е. может и не быть в файле public класса

Default Access
	* Так называемый пакетный доступ
	
	* При пакетном доступе классы из разных пакетов не могут видеть друг друга
		package cert;
			class Beverage { }
			
		package exam.stuff;
			import cert.Beverage;
                class Tea extends Beverage { }
			
		// Ошибка компиляции 
		Can't access class cert.Beverage. Class or interface must be public, in same package, or an accessible member class.
			import cert.Beverage;
			
Public Access
	* Уровень доступа при котором класс доступен откуда угодно
		public class A {}
	
	* Не доступен для наследования если помечен как final
	
Abstract Classes
	* Никогда не инстанцируются
	
	* Не могут быть final
		public abstract final class A {} //Compile error
		
	* Если хоть один метод помечен как abstract то class должен помечаться как абстрактный
		public class Abstract {
			public abstract void getAbstractName();
		} 
		
		// Ошибка компиляции потому что класс должен быть не абстрактным
		
	* Абстрактный класс может не содержать абстрактных методов
	
	* Абстрактный класс может быть strictfp
	
	* Абстрактный класс может иметь конструкторы и методы
	
Declare Interfaces (Exam Objectives 1.1 and 1.2)
	* интерфейсы пользуются теме же правилами для файло что и классы
	
	* Интерфейсы могут быть иметь следующие модификаторы доступа public и deault
	
	* public interface и public class вместе не могут быть в одном файле
	
	* При декларировании интерфейса можно использовать abstract
	
	* Правила объявления интерфейса:
		■  методы интерфейса всегда public и abstract и нет необходимости это объявлять
			public interface DeclaringInterface {
				public abstract void bounce();
				abstract public void bounce1();
				void bounce2();
				public void bounce3();
				abstract void bounce4();
			}
		■  все переменный объявленные в интерфейсе должны быть public static final
			public static final Apple APPLE = new Apple(); // ok
			
			static final Apple APPLE = new Apple(); // fail
			public final Apple APPLE = new Apple(); // fail
			public final Apple APPLE = new Apple(); // fail
		■  Так как методы интерфейса абстрактны то они НЕ МОГУТ БЫТЬ:
			■  final
			■  strictfp
			■  native
		■  Можно наследовать то интерфейсы через extends
		■  Поддерживается множественное наследование
		■  Не могут наследовать классы

	* При декларировании констант по умолчанию они public static final, ниже представлены легальные объявления
		public int x = 1;
		int x = 1;
		static int x = 1;
		final int x = 1;
		public static int x = 1;
		public final int x = 1;
		static final int x = 1
		public static final int x = 1;  // what you get implicitly
		
Declare Class Members (Objectives 1.3 and 1.4)
	* Модификаторы доступа: public default protected private
	
Protected and Default Members
	* При default доступ имеют только если в одно пакете
		package a;
		class A {
			public void run() {}
		}
		
		package b;
		class B {
			public void run() {
				A a = new A(); // Ошибка компиляции
			}
		}

	* default извне не доступен
	
	* При protected доступ имеют только если в одном пакете или через наследование только у потомков
		package other;
		import certification.Parent;
  		class Child extends Parent {
			public void testIt() {
	        	System.out.println("x is " + x); // No problem; Child inherits x
				
				Parent p = new Parent(); // Can we access x using the p reference?
				System.out.println("X in parent is " + p.x); // Compiler error
		}}
		
Nonaccess Member Modifiers
	* final метод не может быть переопределен
	
	* final аргумент метода не может изменяться в методе
		
		public Record getRecord(int fileNumber, final int recordNumber) {
			recordNumber = 1; //Ошибка КОМПИЛЯЦИИ
		}

	* Abstract Methods это метод не имеющий {},  abstarct ';'.
		Без слова abstract обязательно дожна быть реализация
	
	* модификаторы для методов strictfp, native, synchronized, final
	
	* var-args синтаксис Тип .... <имя параметра>
	
	* var-args - обязан быть последним параметром
	
	* Аргумент то что передается в метод
	
	* Параметр это то что декларируется в методе

Constructor Declarations
	* Имя конструктора должно совпадать с именем класса
		class Foo {
			protected Foo() { }          // this is Foo's constructor
			protected void Foo() { }     // this is a badly named, but legal, method
		}
		
	* Конструктор не может быть static, final, abstract
	
Variable Declarations	
	* В java 2 типа переменных:
		■ Примитивные
		■ Ссылочные
		
		* модификаторы для переменных volatile, transient, synchronized, final
		
Declaring Primitives and Primitive Ranges
		* Все 6 примитвные типы емеют знак
		
		* Самый левый символ это знак
			■ 0 - положительный
			■ 0 - отрицательный
		
			byte - 0 1111111 (0 + 2 в 7й это значение байта) -128 до 127
			
			-2 в (bits-1) - отрицательный ряд
			2 в (bits-1) и –1 - для положительного ряда
			
		Таблица с типами данных и размерами
		|-------------------------------------------------|
		|  Type  |Bits|Bytes|Minimum Range| Maximum Range |
		|-------------------------------------------------|
		| byte   | 8  | 1   | -2(in 7)    | -2(in 7)  -1  |
		|-------------------------------------------------|
		| short  | 16 | 2   | -2(in 15)   | -2(in 16)  -1 |
		|-------------------------------------------------|
		| int    | 32 | 4   | -2(in 31)   | -2(in 32)  -1 |
		|--------------------------------------------------
		| long   | 64 | 8   | -2(in 63)   | -2(in 63)  -1 |
		|-------------------------------------------------|
		| float  | 32 | 4   | NA          | NA            |
		|-------------------------------------------------|
		| double | 64 | 8   | NA          | NA            |
		|-------------------------------------------------|

		* длина char 65535	
			
Array Declarations
	* Декларация массива выгдялит так
		int[] key; // рекомендовано
		int key [];
	
	* Декларация многомерного массива выгдялит так
		String[][][] occupantName;
  		String[] managerName [];
  		
  	* При декларировании массива нельзя задавать его длину
  		int[5] scores; // Ошибка компиляции 

Static Variables and Methods
	* Декларируемые как static могу быть
		■  методы
		■  переменные класса
		■  класс вложенный в другой класс
		■  Блок иницализации
	
	* НЕ могут быть декларируемые как static
		■  конструкторы
		■  классы, если только они не вложенные
		■  интерфейсы
		■  методы локальных вложенных классов
		■  переменные локального вложенного класса
		■  локальные переменные
	
Declaring Enums
	* Декларирование вне класса
		enum CoffeeSize { BIG, HUGE, OVERWHELMING }
	
	* Декларирование внутри класса
		class Coffee2 {
			enum CoffeeSize {BIG, HUGE, OVERWHELMING }
			CoffeeSize size;
		}
		
	* Внутри метода НЕЛЬЗЯ декларировать перечисление
	
	* точка с запятой не обязательна после перечисление
	
	* Но если есть конструктор то тогда ';' обязательна
	
	* Если enum декларируется вне класса то оно НЕ ДОЛЖЕН БЫТЬ 
		static, final, abstract, protected, or private.
	
	* enum имеет метод values() - который возвращает массив перечислений
	
	* Конструктор enum НЕЛЬЗЯ вызывать
	
	* Конструктор enum может иметь больше 1го параметра
	
	* Можно переопределять метод для определенного значения перечисления (Анонимным классом)
		OVERWHELMING(16) {
			public String getLidCode() {   // override the method defined in CoffeeSize
			return "A"; 
			}
		}
	
Encapsulation (Exam Objective 5.1)
	* Это всегда private переменная или реже protectred
	
	* Доступ через API get/set

Inheritance, Is-A, Has-A (Exam Objective 5.5)
	* При наследовании наследуются все кроме public члены
	
	* При наследовани static и не static методы c с одним именем это ошибка
		class B  extends A{
			public  void getA(){} // Compiler erro
		}

		class A {
			public static void getA(){}
		} 
	
	* is - a кода один класс расширяет другой или когда иплементирует интерфейс
	
	* все классы is-a Object
	
	* interface is-a Object
	
	* has - a - говорит об использовании
		public class Animal { }
  		public class Horse extends Animal {
     		private Halter myHalter;
  		}
  		
  		// Horse has Halter
	
Polymorphism (Exam Objective 5.2)
	* Ссылочная переменная может ссылаться на любой объект того типа что и задекларирована или
		она может ссылаться на любой подтип декларируемого типа
	
	* Присвоение переменной возможно ели это еще и интерфейс
		public interface Animatable {
 		    public void animate();
		}
		
		class PlayerPiece extends GameShape implements Animatable {
		     public void movePiece() {
		       System.out.println("moving game piece");
		     }
		     public void animate() {
		       System.out.println("animating...");
			}
		// more code 
		}
	
		В зависимости от типа ссылочной переменной:
			■ An Object (since any object inherits from Object)
			■ A GameShape (since PlayerPiece extends GameShape)
			■ A PlayerPiece (since that's what it really is)
			■ An Animatable (since PlayerPiece implements Animatable)
			
		В текущем примере PlayerPiece может присвоин следующим ссылочным переменным
			PlayerPiece player = new PlayerPiece();
        	Object o = player;
        	GameShape shape = player;
        	Animatable mover = player;
		
	* Полиморфный вызов методов применяются только к экземплярам методов
	
Overriding / Overloading (Exam Objectives 1.5 and 5.4)
	* Полиморфизм использует ссылку в высокой иерархии чтобы вызывать переопределенные методы классов
		public class TestAnimals {
		    public static void main (String [] args) {
		      Animal a = new Animal();
		      Animal b = new Horse();  //Animal ref, but a Horse object
		      a.eat(); // Runs the Animal version of eat()
		      b.eat(); // Runs the Horse version of eat()
		    }
		 }

		class Animal {
		    public void eat() {
		      System.out.println("Generic Animal Eating Generically");
		} }
		  class Horse extends Animal {
		    public void eat() {
		      System.out.println("Horse eating hay, oats, "
		                         + "and horse treats");
		}
		     public void buck() { }
		}

	* Если вызвать метод который не определенн ссылкой то будет ошибка компиляции
		Animal c = new Horse();
  		c.buck();  // Can't invoke buck(); Animal class doesn't have that method
  		
  	* Переопределенные методы не могут быть более закртыми чем сам метод т.е. public метод не может быть protected, private (static)
  	
  	* Если метод у родителя private можно объявить с такой же сигнатурой метод в подклассе так как не наследуются private методы
  	
  	* Если у родителя метод final то его переопределение вызовет ОШИБКУ КОМПИЛЯЦИИ
  	
  	* Переопределяемый метод не может быть static в одном из классов, если только не в обоих классах сделать static
  	
  	* Правила переопределения методов
  		■ Аргументы методов должны в точности совпадать
  		■ Возвращаемый тип должен быть тем же самым или подклассом
  		■ Уровень доступа должен быть не выше чем у переопределяемого метода (Обратное работает)
			class Animal1 {
				protected  void eat() {
					System.out.println("Generic Animal Eating Generically");
				}
			}
			
			class Horse1 extends Animal1 {
				public  void eat() {
					System.out.println("Horse eating hay, oats, " + "and horse treats");
				}
			
				public void buck() {
				}
			}
		■ Экземпляры методов могут переопределены только если они наследуются от суперкласса и не final private.
		  Подкласс в другом пакете может переопределить только protected и public методы
		■ Переопределенный метод может кидать любой unchecked (runtime) исключение (NullPointerException, ArrayIndexOutOfBoundsException)
		■ Переопределенный метод НЕ МОЖЕТ бросать более широкое исключение или новое checked
		■ Переопределенный метод может бросать более специализированное исключение
		■ Нельзя переопределять final метод
		■ Нельзя переопределять static метод
		■ Если метод не может быть унаследован то он не может быть переопределен
		
	* Вызвать версию родительского класса можно через переменную super
	
	* В переопределенном методе может не присутствовать Exception
		class Animal1 {
			protected  void eat() throws Exception{
				System.out.println("Generic Animal Eating Generically");
		}}
		
		class Horse1 extends Animal1 {
			public  void eat() {
				System.out.println("Horse eating hay, oats, " + "and horse treats");
		}}
		
	* Стоит аккуратно подходить к вызову метода с исключением оно дожно декларировать или быть в try/catch	
		public class TestAnimals {
			public static void main(String[] args) {
				Animal1 a = new Animal1();
				Horse1 b = new Horse1();
				b.eat(); // Compiler happy
				a.eat(); // Compiler unhappy
			}
		}
	
Overloaded Methods
	* Правила перегрузки методов
		■ Перегруженный метод ОБЯЗАН поменять список аргументов
		■ Перегруженный метод может менят ь возвращаемое значение
		■ Перегруженный метод может менять модификатор доступа
		■ Перегруженный метод CAN декларировать расширенное исключение или новое
		■ Метод можно перегружать как в самом классе так и в подклассах
	
Invoking Overloaded Methods
	* При вызове переопределенного метода выбирается тип который соответсвует задекларированному типу, а а не объекту
		public class OverloadCall {
			public void run(C1 c) {System.out.println("C");}
			public void run(BZ b) {System.out.println("B");}
		
			public static void main(String[] args) {
				BZ b = new BZ();
				C1 c = new C1();
				C1 cAsb = new BZ();
		
				OverloadCall o = new OverloadCall();
				o.run(b);    // B
				o.run(c); 	 // C
				o.run(cAsb); // ВЫВОД С - ЗАПОМНИ ОПРЕДЕЛЯЕТСЯ ПЕРЕМЕННОЙ А НЕ RUNTIME ОБЪЕКТОМ
		}}
		
		class C1 {}
		
		class BZ extends C1 {}

Reference Variable Casting (Objective 5.2)
	* Чтобы сделать компилятор счастливее можно применять Cast ссылок
		BZ zb = (BZ) c; // downcast
		// В случае если c в Runtime = BZ то все ок иначе ClassCastException
	
	* Cast ДОЛЖЕН применяться только к одинаковой иерархии
		C1 z = (C1) (new String("")); // ошибка компиляции String нельзя привести к C1

Implementing an Interface (Exam Objective 1.2)
	* При имплементации интерфейса методы в классе ТОЛЬКО public
	
	* Такие же правила как при и переопределении
	
	* Такие же правила что и для абстрактныйх классов

Return Type Declarations
	* Возвращаемое значение может быть подтипом только в Java 1.5
		public abstract class Animal { }
		public class Bear extends Animal { }
		public class Test {
			public Animal go() {
				return new Bear();  // OK, Bear "is-a" Animal
		} }
	
	* Возвращаемое значение может быть null
		public Button doStuff() {
			return null;
		}
	
	* Массив легальный возвращаемы тип
	
	* В методах где возвращаемое значение примитивного типа можно возвращать тип который может быть приведен автоматически
		public double get(){
			char c = 'c';
			return c;
		}
	
	* В методах где возвращаемое значение примитивного типа можно возвращать приведенные типы
		public int get(){
			float f = 11f;
			return (int) f;
		}		

	* Метод возвращающий void не может возвращать значение
		public void bar() {
			return "this is it";  // Not legal!!
		}		

	 * В методах где возвращаемый элемент объектная ссылка можно возвращать неявно приведенные типы
		public Object getObject() {
		     int[] nums = {1,2,3};
		     return nums;  // Return an int array, which is still an object
		}
	 
		public interface Chewable { }
		   public class Gum implements Chewable { }
		   public class TestChewable {
		       // Method with an interface return type
		       public Chewable getChewable() {
		         return new Gum();  // Return interface implementer
		      }
		}
	 
Constructors and Instantiation (Exam Objectives 1.6, 5.3, and 5.4)
Constructor Chaining
	* Пусть есть такой код 
		Horse h = new Horse();
		
		Создание класса вызывает следующую последовательность действий:
			■ Вызывается конструктор Horse. Каждый конструктор вызывает конструкторсупер класса
			■ Вызывается Animal конструктор (Animal is the superclass of Horse)
			■ Вызывается конструктор Object
			■ Переменные экземпляра Object принимают соответсвующие значение
			■ Конструктор Object заканчивает
			■ Переменные экземпляра Animal принимают соответсвующие значение
			■ Конструктор Animal заканчивает 
			■ Переменные экземпляра Horse принимают соответсвующие значение
			■ Конструктор Horse заканчивает
			
Rules for Constructors
	* Конструктор может использоваь любой модификатор доступа
	
	* Имя конструктора совпадает с именем класса
	
	* Конструктор НЕ ИМЕЕТ возвращаемого значения
	
	* Если вы не напишить конструктор в коде - конструктор по умолчанию будет добавлен
	
	* Если класс имеет конструктор с параметром - КОНСТРУКТОР по умолчанию не создается
	
	* Каждый конструктор как первое значение должен либо вызвать переопределенный конструктор либо this() либо конструктор супер класса super()
	
	* Если вы не напечатаете в своем конструкторе без параметров перегруженного конструктора this() или супер конструктор super() - компилятор добавит super()
	
	* Вызов super() может как с параметрами так и без
	
	* Только статические переменные переменные могут быть частью вызова super() или this()
	
	* конструктор может быть вызван только другим конструктором - в методе его вызывать нельзя
	
Statics (Exam Objective 1.3)
	* Нельзя использовать не статик члены в статических методах
		class Foo {
			int x = 3;
			float y = 4.3f;
			public static void main (String [] args) {
			for (int z = x; z < ++x; z--, y = y + z) // complicated looping and branching code
		} }
		//ошибка компиляции при использовании не статической переменной
		
	* Статические методы не могут быть переопределены
	
	* Компилятор заменяет вызов ref.staticMethod() на Class.staticMethod()
		d.doStuff();
		becomes:
		Dog.doStuff();

Coupling and Cohesion (Exam Objective 5.1)
	* coupling - is the OO principle most closely associated with making sure classes know about other classes only through their APIs.
	
	* cohension - is the OO principle most closely associated with making sure a class is designed with a single, well-focused purpose.
	
Literals, Assignments,andVariables (Exam Objectives 1.3 and 7.6)
	* Примеры примитивных литералов:
		■ 'b'		// char literal
		■ 42			// int literal
		■ false		// boolean literal
		■ 23.44		// double literal
		
Integer Literals
	* Существует 3 способа представить integer число в Java
		■ decimal (основание 10)
		■ octal (основание 8)
		■ hexadecimal (основание 16)
		
	* Decimal Literals
		Обычные значения int
			int i = 10;
			
	* Octal Literals:
		■ Используются числа от 0 до 7
		■ Запись идет с лидирующим 0
		■ Может использоваться до 21 цифры не считая лидирующего 0 
		
		class Octal {
		    public static void main(String [] args) {
		      int six = 06;     // Equal to decimal 6
		      int seven = 07;   // Equal to decimal 7
		      int eight = 010;  // Equal to decimal 8
		      int nine = 011;   // Equal to decimal 9
		      System.out.println("Octal 010 = " + eight);
		} }			
		
	* Hexadecimal Literals
		■ Используют для представления числа от 0 до f
		■ В java все равно на регистр букв
		■ Префикс 0x
		■ Необязательный суфикс  L
		
		class HexTest {
		    public static void main (String [] args) {
		      int x = 0X0001;
		      int y = 0x7fffffff;
		      int z = 0xDeadCafe;
		      System.out.println("x = " + x + " y = " + y + " z = " + z);
		} }
		//x = 1 y = 2147483647 z = -559035650
		
	* Cуффиксы целых примитивных типов
		■ L,l - long
			long jo = 110599L;
  			long so = 0xFFFFl;  // Note the lowercase 'l'

Floating-Point Literals
	* По умолчанию число double, не требует специального суфикса, но имеет его:
		D, d
		
		double d = 110599.995011D; // Optional, not required
  		double g = 987.897;        // No 'D' suffix, but OK because the literal is a double by default
	
	* При создании примитивных типов только float требует специального суфикса :
		F, f
		
		float f = 23.467890;         // Compiler error, possible loss of precision
		float g = 49837849.029847F;  // OK; has the suffix "F"
	
	* ',' - не является разделителем дробной части
	
Character Literals
	* Длина 65535
	
	* Может представляться как символ юникода
		char unicodeChar = '\u004E'; // The letter 'N'
		
	* Пример хитрых валидных присвоений char
		char a = 0x892;        // hexadecimal literal
  		char b = 982;          // int literal
  		char c = (char)70000;  // The cast is required; 70000 is out of char range
  		char c = '\"';    // A double quote
		char d = '\n';    // A newline
  		
  	* Можно присвоить int
  		char c = 1;
  		int i = c = 1;
  		
	* Пример хитрых невалидных присвоений char	
		char e = -29;   // Possible loss of precision; needs a cast
		char f = 70000  // Possible loss of precision; needs a cast
		
Primitive Assignments		
	* byte, short, char могут присваиваться int
	
	* в double могут присваиваться любые типы
	
	* Операция сложения приводит к результату int
		byte a = 1;
		byte b = 1;
		byte c = a + b 
		// Ошибка компиляции компилятор possible loss of precision
  			found   : int
  			required: byte
			 byte c = a + b;
						^
		Это происходит если складываются
			byte + byte
			short + short
			short + byte
	
	* byte не может быть больше 127
		 byte a = 128; //Ошибка компиляции - possible loss of precision
		 //но
		 byte a = (byte) 128; // Все ОК
	
	* Если использовать операторы короткой схемы то они автоматически проводят типы (+=, -=, *=, /=)
		byte b = 127;
		b += 7; // -122
		
		// Эквивалентно
		b = (byte) (b + 7)
		
Variable Scope
	* Scope очень не простая, и путующая штука в экзамене - надо помнить о видимости переменной
		■ Попытка получения доступа к переменной из статического контекста
			class ScopeErrors {
			  int x = 5;
			  public static void main(String[] args) {
			    x++;   // won't compile, x is an 'instance' variable
			  }
			}
		■ Попытка получения доступа к локальной переменной из вложенного метода
			class ScopeErrors {
				public static void main(String [] args) {
			    	ScopeErrors s = new ScopeErrors();
					s.go(); 
				}
				
				void go() {
					int y = 5;
					go2();
			    	y++;        // once go2() completes, y is back in scope
			  	}
				
				void go2() {
					y++;        // won't compile, y is local to go()
				} 
			}
		■ Попытка использования переменной блока после того как код блока закончился
			void go3() {
				for(int z = 0; z < 5; z++) {
					boolean test = false;
	
					if(z == 3) {
						test = true;
						break; 
					}
				}
			
				System.out.print(test); // 'test' is an ex-variable,it has ceased to be...
			}
			
	* Лего попасться на не инициализированных переменных
		int x;
		x++;
		
		public void trick(int sameName){
			sameName++;
			for (int sameName = 0; sameName < array.length; sameName++) { // Уже объявлено как параметр метода
			}
		}

Primitive and Object Type Instance Variables
	* Значения по умолчанию принимаемые переменными класса
		■ Объектная ссылка:				null
		■ ￼byte, short, int, long:		0
		■ ￼float, double:					0.0
		■ boolean:						false
		■ char:							'\u0000'

Array Instance Variables
	* Элементы массива всегда инициализируются значениемя по умолчанию
		public class BirthDays {
		    static int [] year = new int[100];
		    public static void main(String [] args) {
		      for(int i=0;i<100;i++)
		        System.out.println("year[" + i + "] = " + year[i]);
		} }
		
		// Напечатается 100 значений с 0  - year[1..100] = 0 

Local Primitives
	* Локальные переменные и объектные ссылки должны быть инициализированы до использования
		public class TimeTravel {
		    public static void main(String [] args) {
		      int year; // Local variable (declared but not initialized)
		      Date date;
		      System.out.println("The year is " + year + "\nDate is " + date); // Compiler error
		    }
		}

Passing Variables into Methods (Objective 7.3)
	* Ссылки передаются в методы по значению
	
	* Не возможно изменить объектную сслыку в методе можно только изменить значение ее переменной
		class Foo {
		    Bar myBar = new Bar();
		    void changeIt(Bar myBar) {
		      myBar.barNum = 99;
		      System.out.println("myBar.barNum in changeIt is " + myBar.barNum);
		      myBar = new Bar();
		      myBar.barNum = 420;
		      System.out.println("myBar.barNum in changeIt is now " + myBar.barNum);
		    }
		    public static void main (String [] args) {
		      Foo f = new Foo();
		      System.out.println("f.myBar.barNum is " + f.myBar.barNum);
		      f.changeIt(f.myBar);
		      System.out.println("f.myBar.barNum after changeIt is "  + f.myBar.barNum);
		} }

Array Declaration, Construction, and Initialization (Exam Objective 1.3)
	* Создание одномерного массива
		int[] testScores = new int[4];
		
	* Необходимо следить за указанием количества элементов при создании массива
		int[] carList = new int[]; // Will not compile; needs a size
		
	* Создание многомерного массива
		int[][] myArray = new int[3][];
		
Initializing an Array
	* Инициализация многомерного массива
		int[][] scores = new int[3][];	// Declare and create an array holding three references to int arrays
		
		scores[0] = new int[4];	// the first element in the scores array is an int array of four int elements

		scores[1] = new int[6]; // the second element in the scores array is an int array of six int elements

		scores[2] = new int[1]; // the third element in the scores array is an int array of one int element
  		
Initializing Elements in a Loop		
	* У массивов length это свойство
		String[] x = new String[3];
		System.out.println( x.length() ); // compiler error

Declaring, Constructing, and Initializing on One Line
	* Массив можно инициировать сразу
		int x = 9;
		int[] dots = {6,x,8};
		
	* Инициализация многомерного массива по короткой схеме
		int[][] scores = {{5,2,4,7}, {9,2}, {3,4}}; // Создаться 4 объекта в памяти

		Такие элементы содержит массив
			scores[0] // an array of four ints 
			scores[1] // an array of 2 ints 
			scores[2] // an array of 2 ints 
			
			scores[0][1] // the int value 2 
			scores[2][1] // the int value 4

	* такое возможно int[][] a = {{1,2,}, {3,4}};
	
Constructing and Initializing an Anonymous Array	
	* Инициализация анаимного массива
		int[] z = new int [] {10,1};
		
	* Размер анонимного массива нельзя задавать
		 new Object[3] {null, new Object(), new Object()}; // Compiler error
		 
Array Reference Assignments for One-Dimensional Arrays
	* При присвоении массивов проверяется правило IS-A
		Car[] cars;
		Honda[] cuteCars = new Honda[5];
		cars = cuteCars; // OK because Honda is a type of Car
		Beer[] beers = new Beer [99];
		cars = beers; // NOT OK, Beer is not a type of Car
	
	* Массив int [] может быть только переприсвоен ссылочной переменной int []
		int[] splats;
		int[] dats = new int[4];
		char[] letters = new char[5];
		splats = dats; // OK, dats refers to an int array
		splats = letters; // NOT OK, letters refers to a char array

Array Reference Assignments for Multidimensional Arrays
	* 2х мерный массив int не может быть присвоен к одномерному
		int[] blots;
		int[][] squeegees = new int[3][];
		blots = squeegees; // NOT OK, squeegees is a two-d array of int arrays
	
	* ArrayStoreException кидается когда в массив передается объект не того типа, в основном это можно получить в случае полиморфизма
		public class PolymorphicArray {
		public static void main(String[] args) {
			arrayStoreException();
		}

		public static void arrayStoreException() {
			Animal[] catArr = new Cat[1];
			catArr[0] = new Dog();
		}}
		
		abstract class Animal {}
		class Dog extends Animal {}
		class Cat extends Animal {}
		
	* В runtime случится ArrayStoreException
		class A{}
		     class B extends A{}
		     class C extends B{}
		     class D extends C{}
		     public class XLoad{
		          public static void main(String args[]){
		               A[] a=new C[1];
		               a[0] = new B() // В runtime это C[]
		          }
		     }

Initialization Blocks
	* Блок инициализации запускается когда класс впервые загружен - static initialization block
		class SmallInit {
			static int x;
			static { x = 7 ; } // static init block
		}
	
	* Блок инициализации запускается когда создается экземпляр объекта - instance initialization block
		class SmallInit {
			int y;
			{ y = 8; } // instance init block
		}
		
	* instance init block - запускается сразу после вызова super() - конструктора
	
	* Блоки инициализации запускаются в том порядке в котором расположены в файле
		class Init {
		    Init(int x) { System.out.println("1-arg const"); }
		    Init() { System.out.println("no-arg const"); }
		    static { System.out.println("1st static init"); }
		    { System.out.println("1st instance init"); }
		    { System.out.println("2nd instance init"); }
		    static { System.out.println("2nd static init"); }
		    public static void main(String [] args) {
		      new Init();
		      new Init(7);
		} }
		
		1st static init
		2nd static init
		1st instance init
		2nd instance init
		no-arg const
		1st instance init
		2nd instance init
		1-arg const
		
		Следующие правила вызова блоков инициализации
			■ Блоки инициализации запускаются в том порядке в котором расположены в файле
			■ Статические блоки инициализации запускаются единожды когда класс загружается
			■ Блоки инициализации экземпляра переменной запускаются каждый раз как создается класс
			■ Блоки инициализации экземпляра запускаются сразу после того как конструкторы вызывают super()
			
	* Если в блоке инициализации возникает ошибка то выбрасывается исключение java.lang.ExceptionInInitializerError			
			
Using Wrapper Classes and Boxing (Exam Objective 3.1)
	* В java существуют классы оболочки для примитивных типов
		■ boolean - Boolean
			Boolean(boolean b)
			Boolean(String value)
		
		■ byte - Byte
			Byte(byte b)
			Byte(String value)
		
		■ char - Character
			Character(char value)
		
		■ double - Double
			Double(double d)
			Double(String value)
		
		■ float - Float
			Float(float f)
			Float(double d)
			Float(String value)
		
		■ int - Integer
			Integer(int i)
			Integer(String value)
		
		■ long - Long
			Long(long l)
			Long(String value)
		
		■ short - Short
			Short(short s)
			Short(String value)		 

	* Все оболочные классы имеют метод 
		static <Тип> valueOf()
		Возвращает оболочный тип
			Integer i2 = Integer.valueOf("101011", 2); // Преобразование значения по основанию 2 в тип integer =  43
			i2 = Integer.valueOf(1);
			i2 = Integer.valueOf("1");
			
	* Если при valueOf(String string) или в parseXxx(String string) задать некорректное значение числа то будет выброшена ошибка
		Integer val = Integer.valueOf("11d");
		 java.lang.NumberFormatException: For input string: "11d"
		 
	* static <примитивный тип> parseXxx(String) - возвращает примитивный тип
	
	* У оболочек есть перегруженные статические методы toString()
		String d = Double.toString(3.14);      // d = "3.14"
		
	* Long и Integer предоставляют 3ю версию toString()
		Long.toString(long value,int radix)
			String s = "hex = "+ Long.toString(254,16); // s = "hex = fe"
			
	* Long и Integer предоставляют специальные методы методы для конвертации чисел из 10 в другие системы toXxxString()
		String s3 = Integer.toHexString(254);  // convert 254 to hex
		System.out.println("254 is " + s3);    // result: "254 is fe"
		String s4 = Long.toOctalString(254); // convert 254 to octal
		System.out.print("254(oct) ="+ s4);  // result: "254(oct) =376"
			
	* Все экземпляры оболочных классов имеют ряд так называемых xxxValue() методов
		Integer i2 = new Integer(42);  //  make a new wrapper object
		byte b = i2.byteValue();       //  convert i2's value to a byte primitive
		short s = i2.shortValue();     //  another of Integer's xxxValue methods
		double d = i2.doubleValue();   //  yet another of Integer's xxxValue methods

	* Специальный тип инициализации при создании оболочных типов
		Byte b1 = new Byte((byte)127);
		Short s1 = new Short((short)127);
		Long l1 = (long) 1;
		
	* При сравнении оболочных типов сравниваются классы
		Byte bs2 = 1;
		Long l = (long) 1;
		System.out.println(bs2 == l); // ошибка компиляции
		
		Byte bs1 = 1;
		System.out.println(bs1.equals(l)); // false потому что Byte instanceof Long == false

Boxing, ==, and equals()
	* Примитивные типы будут == если:
		■ они Boolean
		■ они Byte
		■ они Character from \u0000 to \u007f (127)
		■ они Short and Integer from -128 to 127
		
		Integer i1 = 10;
		Integer i2 = 10;
		i1 == i2; // True
		
		Integer i1 = 128;
		Integer i2 = 128;
		i1 == i2; // False because > 127 but equals True
		long l = 128L;
		i1.equals(l) // Будет false
	 
	 * Оболочные классы не могут быть расширены
	 	 Bytes не может быть раширен до Short e.t.c
	 
	 * При передачи в методы где параметрами являются примитивные типы происходит Unboxing и все работает
	 	public class Frodo {
	 		public static void main(String[] args) {
	 			Short myGold = 7;
  				System.out.println(countGold(myGold, 6)); // Сначала произойдет boxing до short потом cast до int (int = byte, short)
	 		}
	 		
	 		public static int countGold(int x, int y) { return x + y; }
	 	}

Overloading (Exam Objectives 1.5 and 5.4)
	 * При overloading и autoboxing если просходит раширение до типа то проверяется IS-A
	 	class WidenAndBox {
	 		static void go(Long x) { System.out.println("Long"); }
            
            public static void main(String [] args) {
                    byte b = 5;
                    go(b); // must widen then box - illegal
			} 
		}
		
	* Расширение привалирует над Boxing
	
	* Расширение привалирует над var-arg
		class AddVarargs {
		    static void go(int x, int y) { System.out.println("int,int");}
		    static void go(byte... x) { System.out.println("byte... "); }
		    public static void main(String[] args) {
				byte b = 5;
		    	  go(b,b);         // which go() will be invoked?
		   	 }
		}
		// ответ int int
	
	* Wrapper не могут быть приведены к друг другу это вызывает ошибку компиляции
		class Dog4 {
			public static void main(String [] args) {
				Dog4 d = new Dog4();
				d.test(new Integer(5));  // can't widen an Integer to a Long
			}
  			void test(Long x) { }
		}

	
	* Boxing привалирует над var-arg
	
	* Правила которые используются при  widening, boxing, and var-args:
		■ Примитивные типы при расширение используют наименьший элемент из возможных
		■ Used individually, boxing and var-args are compatible with overloading.
		■ Нелья приводит один тип оболочки к другому типу (IS-A fails.)
			class Dog4 {
				public static void main(String [] args) {
					Dog4 d = new Dog4();
					d.test(new Integer(5));  // can't widen an Integer to a Long
				}
	  			void test(Long x) { }
			}
		■ Нельзя вместе использовать раширение и Boxing (An int can't become a Long.)
			class WidenAndBox {
				static void go(Long x) { System.out.println("Long"); }
				public static void main(String [] args) {
					byte b = 5;
					go(b);           // must widen then box - illegal
			} }
		■ Можно использовать сначала упаковку а потом расширение. (An int can become an Object, via Integer.)
			class BoxAndWiden {
			  static void go(Object o) {
			    Byte b2 = (Byte) o;
			    System.out.println(b2);
			  }
			// ok - it's a Byte object
			  public static void main(String [] args) {
			    byte b = 5;
			    go(b);       // can this byte turn into an Object ?
			} }
		■ var-args можно совмещать или с widening или boxing.
			class Vararg {
			    static void wide_vararg(long... x)
			                { System.out.println("long..."); }
			    static void box_vararg(Integer... x)
			                { System.out.println("Integer..."); }
			    public static void main(String [] args) {
			    	int i = 5;
			    	wide_vararg(i,i);
			    	box_vararg(i,i);
			    }
			}	
			// результат
			long...
			Integer...	

Garbage Collection (Exam Objective 7.4)
	* Обнуление ссылки на объект делает его доступным для GarbageCollector
	
	* Переназначение ссылки на объект делает его доступным для GarbageCollector
		StringBuffer s1 = new StringBuffer("hello");
		StringBuffer s2 = new StringBuffer("goodbye");
		System.out.println(s1);
		// At this point the StringBuffer "hello" is not eligible
		s1 = s2; // Redirects s1 to refer to the "goodbye" object
		// Now the StringBuffer "hello" is eligible for collection
	
	* Объекты всозданные в методе становятся доступными после окончания метода
	
Tricky Little finalize() Gotcha's
	* finalize() может быть вызван однажды garbage коллектором
	
	* Вызов finalize() может привести в результате сохранению объекта от удаления
	
	* finalize()  может и не вызваться
	
Operators
	* операторы += *= делают cast
	
	* операторы *= *= работают на выражением справа
		int a *= 3 - 2
		 Это не a = 3*a - 
		 Это a = a*(3-2)
		 
	* instanceof null всегда false
	
	* непрямая проверка instanceof true если супер класс имплеметирует интерфейс то и потомки неявно его имплеметирует
		interface Foo { }
		class A implements Foo { }
		class B extends A { }
		...
		A a = new A();
		B b = new B();
		
	  the following are true:
		a instanceof Foo
		b instanceof A
		b instanceof Foo // implemented indirectly
		
	* Нельзя проверять через instanceof 2 разные иерархии классов это Compilation Error
		class Cat { }
		class Dog {
			public static void main(String [] args) {
				Dog d = new Dog();
				System.out.println(d instanceof Cat);
			}
		}
	
	* Массивы это объекты они проверяются True
		if (nums instanceof Object) { } // result is true
	
	* операторы * , / и % имеют приоритет выше чем + и -
	
	* скобки имеют приоритет перед операторами
	
	* При конкотенации строки если поставить скобки то будет вычисляться результат
		String a = "String";
		int b = 3;
		int c = 7;
		System.out.println(a + (b + c)); // Result is String37
		System.out.println(a + (b + c)); // Result is String10
		
	* Если слева строка производится конкатенация
		String s = "123";
		s += "45";
		s += 67;
		System.out.println(s); //1234567
	
	* инкрементное значение i++ - сначала присваивается потом увеличивается
	
	* Быть осторожным с ++ -- для final переменых
		final int x = 5;
		int y = x++;
		//and produces the error:
		Test.java:4: cannot assign a value to final variable x
		int y = x++;
				^
	
	* && and || используются только с булевыми операндами
		if (5 && 6) { } // Compilation error потому что 5 и 6 int
	
	* & и | - вычисляют обе части
	
	* ^ - вычисляет обе части. Если оба операнда одинаковые то значение false

Flow, Control, Exceptions, Assertions
	* УПС
		int y = 5;
		int x = 2;
		if ((x > 3) && (y < 2) | doStuff()) //Не напечатает так как используется короткая схема
		
		if (((x > 3) && (y < 2)) | doStuff()) //Все ок 2я часть вычисляется всегда и все ОК 
		{
			System.out.println("true"); //Не напечатает так как используется короткая схема
			}
		}

		static boolean doStuff() {
			return true;
		}
	
	* в if присвоение возможно только для Boolean и boolean, остальное compilation error
		boolean boo = false;
		if (boo = true) { } //Все ок даже присвоение проходит
		
		int x = 3;
		if (x = 5) { } // Won't compile because x is not a boolean!
		
	* switch проверяет char, byte, short, int, enum
	
	* в switch cast возможен
	
	* в метках switch можно использовать final переменные
		final short s =1;	
		int i = 1;
		
		switch (s) {
			case s:		All OK
				break;
		}
		
		//But,
		final short s;
		s =1;			
		int i = 1;
		
		switch (s) {
			case s:		//Compile error
				break;
		}
		
	* Одинаковые имена меток это Compile error
	
	* Если в выражение switch передать значение ниже int например byte,
		 и в метке указать значение больше значения типа то будет ошибка компиляции
	
		byte g = 2;
		switch(g) {
			case 23: 
			case 128: // 128 > разрешенных 127
		}
		
	* в switch case и : после метки обязательны
	
	* В switch char сравнивается как unicode
	
	* В switch при char работает и значение не unicode char и unicode char
				char c = '1';

		switch (c) {
			case 65535: //Legal last char
				System.out.println("1");
				break;

			case '\u0001': //Legal
				System.out.println("1"); 
				break;

			case 65536: 
				System.out.println("1"); //Compile error значение юольше разрешенного 65535 для char
				break;

			default:
				System.out.println("Default");
				break;
		}
		
		char c = '\u0001';
		
		switch (c) {
			case '\u0001':
				System.out.println("\u0001"); //Напечатается Юникод символ
				break;
		}

  Loops and Iterators (Exam Objective 2.2)
	* В блоке увеличения переменной может быть печать, анонимное создание класаса и т п
		int d = 3;
		for (int a = 1; d != 1; System.out.println("iterate")) {
			d = d - a;
		}

		int b = 3;
		for (int a = 1; b != 1; new String()) {
			b = b - a;
		}
		
		//Но
		int b = 3;
		for (int a = 1; b != 1; {new String()}) { // ошибка из за {}
			b = b - a;
		}
		
	* continue - используется только в циклах
	
	* break - используется в циклах и switch
	
	* Метка должна предворять цикл или иметь {} в случае наличия выражение перед ней
	
		label: //All OK 
			for (int i = 0; i < args.length; i++) {
				System.out.println("InLOOP");
				break label;
			}

		// Но ошибка если что то есть
		label: //Compile error
			System.out.println("Before Loop");
			for (int i = 0; i < args.length; i++) {
				System.out.println("InLOOP");
				break label;
			}
			
		// Но нет ошибки если есть {}
		label: { //OK
			System.out.println("Before Loop");
			for (int i = 0; i < args.length; i++) {
				System.out.println("InLOOP");
				break label;
			}
		}
		
Handling Exceptions (Exam Objectives 2.4 and 2.5)
	* Иерархия классов Exception
		Object
		  |
	   Throwable
	    |	   |
	 Error    ____Exception______
	 |		|					|
Others... RuntimeException	 Others... 

	* Если в коде выбрасывается исключение и оно checked то будет compile error
		
		//Fail IOException нужно задекларировать
		public void doStuff() {
			try {
				// risky IO things
			} catch(IOException ex) {
				// can't handle it
				throw ex; // Can't throw it unless you declare it
			}
		}
	
	* finally может не вызваться если в try или catch вызван System.exit()  
		
Common Exceptions and Errors (Exam Objective 2.6)
	*Throw JVM
		ArrayIndexOutOfBoundsException
		ClassCastException
		NullPointerException
		ExceptionInInitializerError
		StackOverflowError
		NoClassDefFoundError
	
	*throw Programmatically
		IllegalArgumentException
		IllegalStateException
		NumberFormatException
		AssertionError

Working with the Assertion Mechanism  (Exam Objective 2.3)
	*Валидное использование Assertion
		int x = 1;
		boolean b = true;
		int aReturn() { return 1; }
		
		assert(x == 1);
		assert(b);
		assert true;
		assert(x == 1) : x;
		assert(x == 1) : aReturn();
		assert(x == 1) : new ValidAssert();
		
	*Невалидное использование Assertion
		void noReturn() { }
		
		assert(x = 1); // none of these are booleans
		assert(x);
		assert 0;
		assert(x == 1) : ; // none of these return a value
		assert(x == 1) : noReturn();
		assert(x == 1) : ValidAssert va;
		
	* До версии 1.4 слово assert можно использовать как идентификатор
		int assert = getInitialValue();
		if (assert == getActualResult()) {
			// do something
		}
	  
	  Если использовать компиляцию для 1.6 будет ошибка, 
	  но можно сделать javac -source 1.3 OldCode.java - все ок хотя если использовать assert как ключевое слово то это ошибка
	  
	 * 2 опции для включения компиляторов 5,6 
	 	-source 1.6 or -source 6
	 	-source 1.5 or -source 5
	 
	 * Компиляция под разные версии JVM
	 	javac -source 1.3 TestAsserts.java
	 	javac -source 1.4 TestAsserts.java
	 	javac -source 1.5 TestAsserts.java
	 	javac -source 5 TestAsserts.java
	 	javac -source 1.6 TestAsserts.java
	 	javac -source 6 TestAsserts.java
	 
	 * Включение assertion в runtime
	 	java -ea com.pack.TestClass
	 	java -enableassertions com.pack.TestClass
	 	
	 * Выключение assertion в runtime
	 	java -da com.pack.TestClass
	 	java -disableassertions com.pack.TestClass
	 	
	 * Частичное исключение классов
	 	java -ea -da:com.geeksanonymous.Foo Test
	 	
	 * Частичное исключение пакетов
	 	java -ea -da:com.geeksanonymous...
	 	
	 * Tricky assertion
	 	java -ea -dsa Enable assertions in general, but disable assertions in system classes.

Using Assertions Appropriately (По конвеции Sun)
	 * Inappropriate использовать assertion для валидации аргументов в public методах
		 public void doMore(int x) {
			assert (x > 0);
			// do things with x
		}
	 
	 * Inappropriate использовать assertion для валидации аргументов командной строки
	 
	 * Inappropriate использовать assertion для изменения логики работы программы, при вызове assertion и без него логика остается таже
	 	public void doStuff() {
			assert (modifyThings());
			// continues on
		}
		
		public boolean modifyThings() {
			y = x++;
			return true;
		}
	 
	 * Appropriate использовать assertion для валидации аргументов в private методах
	 	private void doMore(int x) {
			assert (x > 0);
			// do things with x
		}
	
	* Appropriate использовать assertion для кода который точно никогда не выполнится даже в public методах
		switch(x) {
			case 1: y = 3; break;
			case 2: y = 9; break;
			case 3: y = 27; break;
			default: assert false; // we're never supposed to get here!
		}

Strings
	* Создание строк генерирует разное число объектов
		String s = "abc"; // creates one String object and one 
							// reference variable
		// В этом случае "abc" отправляется в pool и создается ссылка s 
		
		String s = new String("abc"); // creates two objects, 
										// and one reference variable
		//В этом случае создается объект в обычной памяти, создается ссылка, а также "abc" помещается в пул				
		
	* Методы которые встречаются на экзамене
		■  public charAt(index) 					Returns the character located at the specified index
		■  public concat(string)					Appends one String to the end of another ( "+" also works)
		■  public equalsIgnoreCase(string) 		Determines the equality of two Strings, ignoring case
		■  public length() 						Returns the number of characters in a String
		■  public replace(char, replaceChar)		Replaces occurrences of a character with a new character
		■  public substring(startPos) 			Returns a part of a String
		■  public substring(startPos, endPos)	Returns a part of a String
		■  public toLowerCase() 					Returns a String with uppercase characters converted
		■  public toString() 					Returns the value of a String
		■  public toUpperCase() 					Returns a String with lowercase characters converted
		■  public trim() 						Removes whitespace from the ends of a String
	
	* У строк length это метод
		String x = "test";
		System.out.println( x.length ); // compiler error
		
	* substring() в Java хитрый
		String x = "0123456789"
		System.out.println( x.substring(5) ); // output is "56789"
		System.out.println( x.substring(5, 8)); // output is "567"
		//Во втором случае с 5го индекса и до 8го индекса или до 7го включительно
	
	* Строковые литералы в одном классе представляют собой ссылки на один и тот же объект. 

	* Строковые литералы в разных классах, но в одном пакете представляют собой ссылки на один и тот же объект. 

	* Строковые литералы в разных классах и разных пакетах всё равно представляют собой ссылки на один и тот же объект )). 
	
	* Строки, получающиеся сложением констант, вычисляются во время компиляции и далее смотри пункт первый.

	* Строки, создаваемые во время выполнения НЕ ссылаются на один и тот же объект.
	
	* Метод intern в любом случае возвращает объект из пула, вне зависимости от того, когда создается строка, на этапе компиляции или выполнения.
	
			//In File Other.java
		package other;
		public class Other { public static String hello = "Hello"; }
		
		//In File Test.java
		package testPackage;
		import other.*;
		class Test{
		  public static void main(String[] args) {
		    String hello = "Hello", lo = "lo";
		    System.out.print((testPackage.Other.hello == hello) + " ");
		    System.out.print((other.Other.hello == hello) + " ");
		    System.out.print((hello == ("Hel"+"lo")) + " ");
		    System.out.print((hello == ("Hel"+lo)) + " "); // runtime
		    System.out.println(hello == ("Hel"+lo).intern());
		  }
		}
		class Other { static String hello = "Hello"; }
		
		//Вывод true true true false true
		
StringBuffer, StringBuilder
	* Методы которые встречаются на экзамене для StringBuffer (для StringBuilder они not sychronized)
		■  public synchronized StringBuffer append(String s) - This method will take many different arguments, including boolean, char, double, float, int, long, and other
			StringBuffer sb = new StringBuffer("set ");
			sb.append("point");
			
		■  public StringBuilder delete(int start, int end)
			StringBuilder sb = new StringBuilder("0123456789");
			System.out.println(sb.delete(4,6)); // output is "01236789"
			
		■  public StringBuilder insert(int offset, String s)
			StringBuilder sb = new StringBuilder("01234567");
			sb.insert(4, "---");
			System.out.println( sb ); // output is "0123---4567"
			
		■  public synchronized StringBuffer reverse()
			StringBuffer s = new StringBuffer("A man a plan a canal Panama");
			sb.reverse();
			System.out.println(sb); // output: "amanaP lanac a nalp a nam A"
			
		■  public String toString()
		
	* Методы которые пересекаются с классом String
		String s = ";";
		StringBuffer sb = new StringBuffer();
		
		s.substring(10);
		sb.substring(10);
		
		s.substring(10, 12);
		sb.substring(10, 12);
		
		s.charAt(1);
		sb.charAt(1);
		
		s.length();
		sb.length();
		
	* У StringBuffer не переопределен equals
		StringBuffer sb1 = new StringBuffer("1");
		StringBuffer sb2 = new StringBuffer("1");
		System.out.println(sb1.equals(sb2));	// Будет false
		
		StringBuffer sb12 = new StringBuffer("1");
		StringBuffer sb22 = new StringBuffer(sb12);
		sb12 =sb22;
		System.out.println(sb12.equals(sb22)); // Будет true

File Navigation and I/O (Exam Objective 3.2)
	* I/O Классы для экзамена
		■  File - абстрактное представление файла и директорий с путями до них 
		
		■  FileReader - класс для чтения символа из файла. Метод read() - читает один символ. Читает потоки символов. Фиксированный набор символов.
			FileReader - обычно оборачивают Высокоуровнемы классами Reader, таким как BufferedReader - который улучшает производительность засчет буфферизации 
			и предоставляет более удобные способы для работы с данными
		
		■  BufferedReader - lower-level Reader. В сравнении с FileReader считывает относительно большие куски данных из файла и помещает в буфер.
			Когда запашиватся символ или строка данных они достаются из буфера - это уменьшает количество обращений к файлу тем самым увеличивается
			производительность.
			Кроме того BufferedReader предоставляет более удобные, по сравнению с FileReader методы например readLine() - считывает следующую строку из файла 
		
		■  FileWriter - используется для записи символа в файл. Его методы write() позволяют записывать: символ(ы), или строки в файл.
			FileWriter обычно оборачивают Высокоуровнемы классами Writer таким как BufferedWriter или PrintWriter, которые предоставляю лучшую производительность 
			и более удобные методы для записи данных в файл.
			
		■  BufferedWriter - используется для высокоуровнего представления классов таких как FileWriter. В сравнении с FileWrite записывает относительно большие куски данных
			 порциями, тем самым уменьшая количество тяжелых операций записи.
			 BufferedWriter предоставляет удобные методы для записи в файл, например newLine() - автоматически создает платформенно специфичный символ новой строки
			 
		■  PrintWriter - самый мощный и доработанный класс
		
		■  Console - класс для работы с консолью

	* Обязательно нужен import java.io.*;
	
	* new File("fileWrite1.txt") не создает еще файл
		newFile = file.createNewFile() - создает файл или ссылку на существующий возвращает boolean
		System.out.println(file.exists());  // look for a real file
		
	* Первый вызов createNewFile() возвратит true
	
	* Повторны вызов createNewFile() возвратит false
		
	* createNewFile() создает новый файл только если он не существует
	
Using FileWriter and FileReader
	* Работа с файлами через Witer/Reader
		public static void main(String[] args) throws IOException {
			File fileToWrite = new File("FileToWrite.txt");
			FileWriter fileWriter = new FileWriter(fileToWrite);
			BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
			bufferedWriter.write("Hello");
			bufferedWriter.newLine();	// добавляет \n
			bufferedWriter.write("Hello1");
			bufferedWriter.flush();
			bufferedWriter.close();
			
	
			File fileToRead = new File("FileToWrite.txt");
			FileReader fileReader = new FileReader(fileToRead);
			BufferedReader bufferedReader = new BufferedReader(fileReader);
			System.out.println(bufferedReader.readLine());
			bufferedReader.close();
			
			File toRename = new File("rename.txt");
			fileToRead.renameTo(toRename);
		}	
			
	* FileWriter - нужно делать flush() и close()
	
	* FileWriter fw = new FileWriter(file); // Физически создает файл
	
	* FileReader - read(char [] buffer), обязательно нужно закрывать
	
	* Reader не иммет flush()
	
	* File - можно привезать и к директории File(File директория, String имя_файла)
	
	* Если не создать директорию вызвав метод но передать в конструктор то будет ошибка java.io.IOException: No such file or directory
		File myDir = new File("mydir");
		// myDir.mkdir(); // call to mkdir() omitted!
		File myFile = new File(myDir, "myFile.txt");
		myFile.createNewFile();	// exception if no mkdir!
	
	* метод delete() у класса File не может удалить директорию если она не пустая
	
	* renameTo(File, имя) - выбросит NullPointerEception если передать null в имя нового файла
	
	* Важные методы и конструкторы для I/O
		* File extend Object
			■  new File(File, String)
			■  new File(String)
			■  new File(String, String)
			
			//Методы
			■  boolean createNewFile() throws IOException
			■  boolean delete() - удаляет либо файл либо директорию, директория должна быть пустая. Не бросает checked Exception
			■  boolean exists() - Не бросает checked Exception
			■  boolean isDirectory() - Не бросает checked Exception
			■  boolean isFile() - Не бросает checked Exception
			■  String [] list() - список директорий. Не бросает checked Exception
			■  boolean mkdir() - Не бросает checked Exception
			■  boolean renameTo(File) // Переименовывает директории даже если не пустые. Не бросает checked Exception
				
				File newName = new File(delDir, null); 	// Имя файла null
				delFile2.renameTo(newName); 			// Выбросит NullPointerException
			
		* FileWriter extend Writer
			■  new FileWriter(File)
			■  new FileWriter(String)
			
			//Методы
			■  close() - закрыть поток
			■  flush() - сбросить данные поток
			■  write(String) - записать в файл

		* BufferedWriter extend Writer
			■  new FileWriter(Writer)
			
			//Методы
			■  close() - закрыть поток
			■  flush() - сбросить данные поток
			■  write(String) - записать в файл
			■  newLine()
			
		* FileReader extend Reader
			■  new FileReader(File)
			■  new FileReader(String)
			
			//Методы
			■  close() - закрыть поток
			■  Reader (InputStreamReader) read() - считать из файла в файл
			
		* BufferdFileReader extend Reader
			■  new BufferdFileReader(Reader)
			
			//Методы
			■  close() - закрыть поток
			■  Reader (InputStreamReader) read() - считать из файла в файл
			■  String readLine() - возвращает null если нет данных
			
		* PrintWriter extend Writer
			■  new PrintWriter(Writer)
			■  new PrintWriter(OutputStream)
			■  new PrintWriter(File) - Java 5
			■  new PrintWriter(String) - Java 5
			
			
			//Методы
			■  close() - закрыть поток
			■  flush() - сбросить данные поток
			■  print()
			■  println()
			■  printf()
			■  format() 

			File toRename = new File("rename.txt");
			FileWriter fw = new FileWriter(toRename);
			PrintWriter pw = new PrintWriter(fw);
			// println запись в файл
			pw.println("data");
			pw.println(1);
			pw.println('c');
			pw.println(1l);
			pw.println(1f);
			pw.println(1d);
			pw.printf("%1d", 1, 2);
			pw.flush();
			pw.close();

	
	* Для поиска файла используется метод String [] search()
		String[] files = new String[100];
		File search = new File("searchThis");
		files = search.list();
		
	* Работа с файлом чтение с помощью потоков BufferedInputStream
	 	FileInputStream fis = new FileInputStream(f2);
		BufferedInputStream bif = new BufferedInputStream(fis);
		bif.read();
		bif.close();
	
java.io.Console Class
	* System.console() - возвращает ссылку на физическую консоль, невозможно использовать если нет доступа

	* char[] readPassword - возвращает набор символов чтобы не быть помещенным в StringPool
	
	* Получение консоли Console c = System.console();
	
	* pw = c.readPassword("%s", "pw: "); - 1й параметр формат 2й приветствие
	
	* c.format("%c", char_) - форматированный вывод
	
Serialization (Exam Objective 3.3)
	* ObjectOutputStream.writeObject() // serialize and write
	
	* ObjectInputStream.readObject() // read and deserialize
	
	* Пример сериализации и десирализации
		import java.io.*;
		class Cat implements Serializable { } // 1
		public class SerializeCat {
			public static void main(String[] args) {
				Cat c = new Cat();  // 2
				try {
					FileOutputStream fs = new FileOutputStream("testSer.ser"); ObjectOutputStream os = new ObjectOutputStream(fs); os.writeObject(c); // 3
					os.close();
				} catch (Exception e) { e.printStackTrace(); }
		
				try {
					FileInputStream fis = new FileInputStream("testSer.ser"); ObjectInputStream ois = new ObjectInputStream(fis);
					c = (Cat) ois.readObject(); // 4
					ois.close();
				} catch (Exception e) { e.printStackTrace(); }
			}
		}	
		
	* Обязательно должен быть имплементирован интерфейс Serializable
		class Cat implements Serializable { }
	
	* Все классы которые ссылаются на сериализованный объект должны быть Serializable
		class Pussy{}
		
		class Cat implements Serializable { 
			Pussy pussy;	// Выдаст ошибку потому что не Serializabe
		}
	
	* Если нет возможности сохранить класс то можно пометить его transient
		class Pussy{}
		class Cat implements Serializable { 
			transient Pussy pussy;	// не будет ошибки но и значение будет пустое
		}
	
	* readObject бросает ClassNotFoundException
	
	* Для того чтобы обойти ограничение несериализуемого объекта можно создать 2 метода для управления процессом сериализации:
		private void writeObject(ObjectOutputStream os){
			// throws IOException { // 1
			try {
				os.defaultWriteObject();// 2
				os.writeInt(theCollar.getCollarSize()); // 3 
			} catch (Exception e) { e.printStackTrace(); }
		}
		
		private void readObject(ObjectInputStream is) {
			// throws IOException, ClassNotFoundException { // 4 
			try {
				is.defaultReadObject();// 5 
				theCollar = new Collar(is.readInt()); // 6
			} catch (Exception e) { e.printStackTrace(); }
		}
	
	* Порядок чтения должен быть таким же как и при записи в случае записи дополнительного кода : os.writeInt(int)
	
	* При сериализации коллекций и массивов - все их элементы должны быть Serializarble
	
	* Object не Serializable
	
	* static не сериализуются потому что принадлежат классу
	
Inheritance and Serialization
	* В случае если супер класс реализует Serializable, а потомок да то при восстановление унаследованная часть будет переинициализирована
		!!!!!Конструктор запустится заново!!!!!
		
		class Animal {
			public String name;
		}
		class Dog extends Animal implements Serializable {
			// the rest of the Dog code
		}
	
	* Вызывается конструктор по умолчанию, если его нет то выбрасывается ошибка  java.io.InvalidClassException: no valid constructor
	
Dates, Numbers, and Currency (Exam Objective 3.4)
	* На экзамене необходимо понимать следующие классы
		■  java.util.Date
		■  java.util.Calendar
		■  java.util.Locale
		■  java.text.DateFormat
		■  java.text.NumberFormat
	
	* Типичные операции
		■  Получить текущую дату и время
			Date d = new Date();
			String s = d.toString();
			
		■  Получить объект позволяющий выполнять операции с датой и временем в вашей локале
			Calendar c = Calendar.getInstance();
			c.add(...)
			c.rool(...)
			
		■  Получить объект позволяющий выполнять операции с датой и временем в различной локале
			Locale loc = new Locale(language);or
			Locale loc = new Locale(language, country);
			
			Calendar c = Calendar.getInstance(loc);
			c.add(...)
			c.rool(...)
			
		■  Получить объект позволяющий выполнять операции с датой и временем в различной локале и применить форматировый вывод в разных стилях
			Calendar c = Calendar.getInstance();
			Locale loc = new Locale(...);
			Date d = c.getTime();
			DateFormat df = DateFormat.getDateInstance(style, loc);
			String s = df.format(d);
			
		■  Получить объект позволяющий выполнять форматирование цифр и валют в различных локалях
			Locale loc = new Locale(...);
			NumberFormat nf = NumberFormat.getInstance(loc);
				-or- NumberFormat nf = NumberFormat.getCurrencyInstance(loc);
			String s = nf.format(someNumber);
	
	* Calendar зависит от локали - Calendar.SUNDAY == c.getFirstDayOfWeek() - проверка дня недели в Англии это Sunday в России Monday
	
	* Calendar абстрактный класс, но имеет статический инициализатор который инстанцирует календарь
	
	* Calendar.getInstance() - инициализируется текущим временем
	
	* В календаре месяц при установке начинается с 0
		Calendar c = Calendar.getInstance();
		c.set(2010, 11, 14); // December 14, 2010
	
	* calendar.add(field, amount) - добавляет значение если не указать отрицательное число
	
	* roll - метод для увеличения или умньшения части даты, но не позволяет перейти границу значения
		// assume c is October 8, 2001
		c.roll(Calendar.MONTH, 9); // notice the year in the output
		Date d4 = c.getTime();
		System.out.println("new date " + d4.toString() ); //new date Fri Jul 08 19:46:40 MDT 2001
	
	* DateFormat - абстрактный класс со следущими статическими инициализаторами
		DateFormat.getInstance();                      						// 9/8/01 7:46 PM
		DateFormat.getDateInstance();                  						// Sep 8, 2001 По умолчанию используется MEDIUM
		
		DateFormat.getDateInstance(DateFormat.SHORT);  						// 9/8/01
		DateFormat.getDateInstance(DateFormat.MEDIUM); 						// Sep 8, 2001
		DateFormat.getDateInstance(DateFormat.LONG);  						// September 8, 2001
		DateFormat.getDateInstance(DateFormat.FULL);   						// Saturday, September 8, 2001
		
		DateFormat.getDateInstance(DateFormat.SHORT, new Locale("us"));		// 9/8/01
		DateFormat.getDateInstance(DateFormat.MEDIUM, new Locale("us"));	// Sep 8, 2001
		DateFormat.getDateInstance(DateFormat.LONG, new Locale("us"));   	// September 8, 2001
		DateFormat.getDateInstance(DateFormat.FULL, new Locale("us"));   	// Saturday, September 8, 2001
		
		String df.format(дата)
		Date df.parse(String)
	
	* DateFormat и NumberFormat - не меняют локали в runtime это ошибка компиляции 
	
	* Класс Locale 2 конструктора и 1 статический инициализатор
		Locale defaultLocale = Locale.getDefault();
		Locale locPT = new Locale("it"); // Italian
		Locale locBR = new Locale("it", "CH"); // Switzerland
	
	* Класс Locale методы
		Locale locBR = new Locale("pt", "BR"); // Brazil
		System.out.println("def " + locBR.getDisplayCountry());      //Brasil
		System.out.println("loc " + locBR.getDisplayCountry(locBR)); //Brasil
		
	* Класс NumberFormat абстрактный со следующими статическими инициализаторами
		Locale locFR = new Locale("fr");
		NumberFormat.getInstance();				//123.457
		NumberFormat.getInstance(locFR);		//123.457
		NumberFormat.getCurrencyInstance();		//$123.46
		NumberFormat.getCurrencyInstance(loc);	//123,46 ?
		
	* Вызов NumberFormat format(число)	
	
	* По умолчанию количество цифр после запятой 3
		float f = 10.1126f;
		NumberFormat fn = NumberFormat.getInstance();
		System.out.println(fn.getMaximumFractionDigits());	//Выведет 3
		System.out.print(nf.format(f1) + " "); 				//Выведет 10,113
		// Можно расширить
		fn.setMaximumFractionDigits(5);
		System.out.print(nf.format(f1) + " "); 				//Выведет 10,1126
		fn.parse("1234.567") // Бросает ParseException и Возвращает Number - который абстрактный и реализуют оболочки примитивных типов
		fn.setParseIntegerOnly(true); //Задает парсинг только integer
		
		fn.parse("1234.567") //Выводит 1234
		
Parsing, Tokenizing, and Formatting (Exam Objective 3.5)
	* Простой пример поиска
		import java.util.regex.*;
		class RegexSmall {
		  public static void main(String [] args) {
		    Pattern p = Pattern.compile("ab");
		    Matcher m = p.matcher("abaaaba");
		    while(m.find()) {
		      System.out.print(m.start() + " ");
		    }
		} }

	0[xX]([0-9a-fA-F])+ - поиск всех 16ти ричных 
	
	* Необходимые импорты
		java.util.regex.Pattern
		java.util.regex.Matcher
	
	* Патерны Regex
		\d - цифры
		\s - пробелы
		\w - слова (буквы, цифры, '_')
		[a-z] - группа
		+ 1 или более
		* - 0 или более
		? - 0 или 1
		^ - отрицание [^abc] - кроме a b c
		. - любой сомвол
		*? , ??, +? - работают для всего выражения с права на лево
		
	
	* Mathcher matcher = pattern.matcher() - получение matcher
		matcher.find() - осуществляет поиск
		matcher.group() - возвращает искомую подстроку
		matcher.start() - возвращает индекс искомой подстроки
	
	* tricky: 
		source: yyxxxyxx
		pattern: .*xx
		result: yyxxxyxx
		
		source: yyxxxyxx
		pattern: .*?xx или .+?xx 
		result: 
			'yyxx'
			'xyxx'
		
		source: yyxxxyxx
		pattern: .??xx
		result: 
			'yxx'
			'yxx'
	
	* Ошибки компиляции
		String pattern = "\d"; // Одиночный \ нужно \\d
			
	* Проверка нулевой строки происходит в regex
		source = "aba"
		pattern = "a?";
		Вызов m.end()
		
		0 1 a
		1 1
		2 3 a
		3 3
		
		Происходит в следующих случаях:
			После последнего символа в строке
			В начале строки
			Между символами после найденного символа
			В начале строки нулевой длинны

Searching Using the Scanner Class
	* Поиск с помощью класса Scanner
		Scanner s = new Scanner(System.in);
		s.findInLine(args[0])
		
Tokenizing
	* split() и Scanner
	
	* Scanner default delimeter is ' '
	
	* Scanner работает со строками, файлами, потоками
	
	* Токены сканера могут быть автоматически сконвертированы в примитивные типы
	
	* Scanner не имеет статических методов
	
	* Пример использования
		import java.util.Scanner;
		  class ScanNext {
		    public static void main(String [] args) {
		      boolean b2, b;
		      int i;
		      String s, hits = " ";
		      Scanner s1 = new Scanner(args[0]);
		      Scanner s2 = new Scanner(args[0]);
		      while(b = s1.hasNext()) {
		        s = s1.next();  hits += "s";
		      }
		      
		      while(b = s2.hasNext()) {
		        if (s2.hasNextInt()) {
		          i = s2.nextInt();  hits += "i";
		        } else if (s2.hasNextBoolean()) {
		          b2 = s2.nextBoolean();  hits += "b";
		        } else {
		          s2.next();  hits += "s2";
		        }
		}
		      System.out.println("hits " + hits);
		    }
		}
		
		If this program is invoked with
		  % java ScanNext "1 true 34 hi"
		
		it produces
		  hits  ssssibis2
	
	* Scanner имеет следующие методы для получения данных
		String next()
		<Type> nextXXX() - <Type> - Boolean, Byte, Short, Integer, Double, Float, BigInteger, BigDecimal
		
		# Кроме char
		
	* Scanner имеет следующие для проверки
		Boolean hasNext()
		Boolean hasNextXXX()
		
	* Scanner может устанавливать локаль и делимитр систему счисления
		scanner.useDelimiter(pattern)
		scanner.useLocale(locale)
		scanner.useRadix(radix)

Tokenizing with Scanner
	* Сканер использую когда надо сделать что то серьезное чем String.split() - обычно используют
		new java.util.Scanner(String);
		new java.util.Scanner(new File(""));
		new java.util.Scanner(new FileInputStream(""));
		new java.util.Scanner(new Readable() {

			@Override
			public int read(CharBuffer cb) throws IOException {
				// TODO Auto-generated method stub
				return 0;
			}

		});
		
Formatting with printf() and format()
	* printf("format string", argument(s));
	
	* Маска printf
		%[arg_index$][flags][width][.precision]conversion char
		
		arg_index - индекс параметра
		flag:
			■ "-" Left justify this argument
			■ "+" Include a sign (+ or -) with this argument
			■ "0" Pad this argument with zeroes
			■ "," Use locale-specific grouping separators (i.e., the comma in 123,456)
			■ "(" Enclose negative numbers in parentheses
		width - минимальная длина колонки для распечатывания
		precision - точность только для чисел с плавающей точкой
		conversion - тип конверсии:
			■  b boolean
			■  c char
			■  d integer
			■  f floating point
			■  s string
		
		int i1 = -123;
		int i2 = 12345;
		System.out.printf(">%1$(7d< \n", i1); 				// > (123)<
		System.out.printf(">%0,7d< \n", i2);				// >012,345<
		System.out.format(">%+-7d< \n", i2);				// >+12345 <
		System.out.printf(">%2$b + %1$5d< \n", i1, false);	// >false + -123<
		
		double a = -1.000011121;
		System.out.format(">%1$0,20.1f<", a); //>-00000000000000001,0<
		
	* Ошибки компиляции при указании format
		System.out.format("%d", 12.3); - ошибка компиляции потому что требуется double
		
Overriding hashCode() and equals() (Objective 6.2)
	* На экзамене попадаюся примеры на правила переопределения а не на equals
		 public boolean equals(Boo b) { } // Compiler error
		 
The equals() Contract
	* Рефлексия.
		It is reflexive. For any reference value x, x.equals(x) should return true.
		Car car = new Car();
		car.equal(car);	// Должно быть true
	
	* Симментрия.
		It is symmetric. For any reference values xand y, x.equals(y) should 
			return true if and only if y.equals(x) returns true.
		Car x = new Car();
		Car y = new Car();
		
		x.equal(y);	// Должно быть true 
		//если
		y.equal(x);	// Должно быть true

	* Транзитивность.
		For any reference values x, y, and z, if x.equals(y) returns 
	true and y.equals(z) returns true, then x.equals(z) must return true.
		Car x = new Car();
		Car y = new Car();
		Car z = new Car();
		
		x.equal(y);	// Если true 
		y.equal(z);	// Если true
		//то
		x.equal(z);	// Должно быть true

		
	* Консистентность.
		 It is consistent. For any reference values xand y, multiple invocations of 
		x.equals(y) consistently return true or consistently return false, pro-vided no information used in equals comparisons on the object is modified.

		Car x = new Car();
		Car y = new Car();
		
		x.equal(y);	// Должно быть true
		x.equal(y);	// Должно быть true
		x.equal(y);	// Должно быть true
		x.equal(y);	// Должно быть true всегда вне зависимости от количества вызовов
		
	* Для не пустой ссылки x вызов x.equals(null) должно быть false
	
	
Overriding hashCode()
	* От вызова к вызову int значение hasCode() не должено меняться
	
	* Два эквивалентных объекта должны иметь одинаковое int значение hashCode()
	
	* Не обязательно у неэквивалентных объектов должено быть разное значение hasCode()
	
	* transient поля нежелательно использовать при формировании hashCode(): 
		В случае десиарилизации они заполнятся значениями по умолчанию

Collections (Exam Objective 6.1)
	* Core интерфейсы:
		■  Collection 
		■  Set 
		■  SortedSet
		■  List 
		■  Map 
		■  SortedMap
		■  Queue 
		■  NavigableSet 
		■  NavigableMap
		 
	* Конкректные имплементации классов
		■  Maps:
			HashMap
			Hashtable
			TreeMap
			LinkedHashMap

		■  Sets:
			HashSet
			LinkedHashSet
			TreeSet

		■  Lists:
			ArrayList
			Vector
			LinkedList

		■  Queues:
			PriorityQueue
			
		■  Utilities:
			Collections
			Arrays
	
	* java.util.Collections - это утилитный класс содержащий полезные методы
		 add(), remove(), contains(), size(), and iterator()  

Ordered(Упорядоченные)
	* ArrayList - упорядочен по индексу
	
	* LinkedHashSet - упорядочен порядку вставки элемента

Sorted(Отсортированные)	
	* LinkedHashSet - упорядочен порядку вставки элемента

List Interface
	* ArrayList
		Упорядоченная по позиции индекса
		Быстрый доступ
		Не отсортирована
		Реализует RandomAccess
		+ получение элемента приблизительно константное время, быстрый обход
		- Медленная вставка и удаление
		не synchronized		
	
	* Vector
		synchronized
		Реализует RandomAccess
		Остальное такое же как и у ArrayList
	
	* LinkedList
		Упорядоченная по позиции индекса
		элементы 2-ды связаны между собой
		добавляет методы удаления из начала и конца (хороший выбор для реализации Стэка и Очереди)
		+ быстрая вставка и удаление
		- медленный доступ чем ArrayList
		имплементирует Queue : peek(), poll(), and offer()
		Реализует RandomAccess
		Остальное такое же как и у ArrayList
		не synchronized	
		
Set Interface
	* HashSet
		не содержит дубликатов
		не упорядочена и не отсортирована
		производительность доступа к данным зависит от реализации hashCode()
		обязательное переопределение hashCode()
		не synchronized
	
	* LinkedHashSet
		упорядоченная в порядке вставки
		2 связный список
		обязательное переопределение hashCode()
		производительность доступа к данным зависит от реализации hashCode()
		не synchronized
		
	* TreeSet
		1 из 2х отсортированных коллекций
		Red-Black tree structure - отсортирована в порядке возрастания (в натуральном порядке)
		имплементирует NavigableSet
		Правила сортировки можно создать свой через Comparable or Comparator
		не synchronized
		
Map Interface
	* HashMap
		не упорядочена и не отсортирована
		производительность доступа к данным зависит от реализации hashCode()
		Можно вставлять null для ключа
		Можно вставлять null для значения
		не synchronized
	
	* Hashtable
		synchronized
		Нельзя вставлять null для ключа
		Нельзя вставлять null для значения
		
	* LinkedHashMap
		упорядоченная в порядке вставки
		2 связный список
		обязательное переопределение hashCode()
		производительность доступа к данным зависит от реализации hashCode()
		- Медленнее HashMap на вставку и удаление
		+ быстреее итерирование
		не synchronized
		
	* TreeMap
		Red-Black tree structure - отсортирована в порядке возрастания (в натуральном порядке)
		имплементирует NavigableMap
		Правила сортировки можно солздать свой через Comparable or Comparator
		не synchronized	
	
Queue Interface (FIFO (first-in, first-out))
	* PriorityQueue
		Новый начиная с Java 1.5
		используется для организации очереди "priority-in, priority out"
			 - элементы упорядочены или в естественном порядке или в соответсвии с Comporator
		Упорядочевание элементов представляет их приоритет
		
	*Таблица на странице 565

Using the Collections Framework (Objectives 6.3 and 6.5)
	* в ArrayList есть метод удаления по значению который удаляет элемент с наименьшим индексом
	
	* Сортировка для List<String> stuff; Collections.sort(stuff);
	
	* Если поместить в List собственный объект без добавления Comparable то будет ошибка
	
	* String реализует Comparable<String>
	
	* Comparable interface используется Collections.sort() и java.util.Arrays.sort() для сортировки коллекци и массивов
	
	* Для реализации Comparable нужно реализовать метод compareTo() соответсвующий следующим характеристикам:
		■ negative 		If thisObject < anotherObject
		■ zero 			If thisObject == anotherObject
		■ positive 		If thisObject > anotherObject
	
	* Comparable<Тип>
		obj1.compareTo(obj2)
		
	* Comparable применяется к текущему классу
	
	* Comparable предполагает только 1 вид сортировки
	
	* Имплементирую String, Wrapper classes, Date, Calendar....
	
	* Интерфейс Comparator<тип> используется для организации любой сортировки, содержин метод 
		int compare(тип объект1, тип объект2)
	
	* В Collections есть перегруженный метод sort() принимающий как 2й параметр Comparator
		Collections.sort(list, ownComparator)
		
	* Comparator отдельный класс
	
	* Объекты разных классов не могут быть отсортированы
	
	* Comparator предполагает только n вид сортировки
	
	* Класс Arrays содержит
		■  Arrays.sort(arrayToSort)
		■  Arrays.sort(arrayToSort, Comparator)		
	
Searching Arrays and Collections
	* Поиск осуществляется с помощью binarySearch()
		binarySearch(<массив/коллекциa>, элемент для поиска)
		binarySearch(<массив/коллекциa>, элемент для поиска, comporator)
	
	* успешный поиск возвращает индекс элемента (0 тоже индекс)
	
	* При естественной сортировки порядок следующий:
		пробел, заглавные буквы, строчные буквы
	
	* Неуспешный возвращает так называемую insertion point = (-(insertion point) -1)
	
	* Коллекция или массив должны быть отсортированы перед поиском
	
	* Если не отсортировать то поиск будет не предсказуемый
	
	* Если массив или коллеция отсортированы в естественном порядке то и поиск будет осуществляться в естественном порядке
		(Обычно это достигается вызовом метода без компоратора)
	
	* Если коллекция была отсортирована компоратором то и поиск должен осуществляться с этим же компоратором
	
	* Компаратор не может быть использован при сортировки простых типов
	
	* На экзамене при решении вопросов на сортировки есть 2 засадных момента:
		■  Поиск по массиву/коллекции которые не были отсортированы
		
		■  Использовании компоратора только или на сортировке или на поиске но не вместе
	
	* Collection содержит методы возвращающие компратор
		■  static Comparator reverseOrder()				- возвращает компаратор который сортирует в обратном порядке
		■  static Comparator reverseOrder(Comparator)	- возвращает компаратор который сортирует в обратном порядке
	
	* Arrays.asList(Object ...) 
	
	* если менять значения в листе или массиве они изменятся в обоих
	
	* list.toArray() - может возвращать либо Object [] либо Тип []
	
	* Обзор методов Collections и Arrays
		java.util.Arrays
			■  static List asList(T[])								- ￼конвертирует массив с список
			■  static int binarySearch(Object[], key)				- осуществляют поис в отсортированном массиве 
			   static int binarySearch(primitive[], key)				возвращают индекс найденного элемента
			■  static int binarySearch(T[], key, Comparator)			- осуществляет поиск в заданном массиве с учетом компоратора
			■  static boolean equals(Object[], Object[])				- сравнивает 2 массива на эквивалентность по содержимому
			   static boolean equals(primitive[], primitive[])
			■  public static void sort(Object[ ] )					- сортирует массив в натуральном порядке (массив должен реализовывать  
			   public static void sort(primitive[ ] )					Comparable иначе ошибка в Runtime)
			■  public static void sort(T[], Comparator)				- сортирует элементы массива используя компоратор
			■  public static String toString(Object[])				- создает строку содержащую контент массива 
			   public static String toString(primitive[])

		java.util.Collections  
			■  static int binarySearch(List, key)					- осуществляют поис в отсортированном списке 
			   static int binarySearch(List, key, Comparator)				возвращают индекс найденного элемента
			■  static void reverse(List)								- переворачивает порядок элементов листе
			■  static Comparator reverseOrder()						- Возвращает компоратор который сортирует в обратном порядке текущего компаратора
			   static Comparator reverseOrder(Comparator)
			■  static void sort(List)								- Сортирует список в натуральном порядке
			   static void sort(List, Comparator)
			
	* Iterator вызывается у коллекций list.iterator()
	
	* hasNext() говорит о том есть ли еще элемент
	
	* только next() передвигает итератор
	
	* В Set уникальные элементы
	
	* если в Set через: boolean add() добавить дублика то результатом вернется false
	
	* Set remove(object) - метод для удаления элемента
	
	* Set имеет toArray()
	
	* HashSet как правило очень быстрый так как он использует hashCode()
	
	* TreeSet это Set где элементы отсортированы
	
	* При использовании TreeSet все элементы должны быть одного типа если нет то будет ClassCastException в runtime
	
	* Чем уникальнее hashCode() тем быстрее Map
	
	* В Map hashCode() - используется для поиска корзины
			equals() - используется для поиска значения
			
Navigating (Searching) TreeSets and TreeMaps
	* java.util.NavigableSet
	 	lower()  	return less
	 	floor()  	return less or equal
	 	higher() 	return high 
	 	ceiling() 	return high or equal
	 
	 * java.util.NavigableMap
	 	lowerKey()  	return less
	 	floorKey()  	return less or equal
	 	higherKey() 	return high 
	 	ceilingKey() 	return high or equal
	
	* Pool значит retrive and remove
	
	* TreeSet
		pollFirst()	- получить и удалить первый элемент
		pollLast()	- получить и удалить последний элемент
	
	* TreeMap
		pollFirstEntry()	- получить и удалить первую пару ключ-значение
		pollLastEntry()		- получить и удалить последнюю пару ключ-значение
		
	* TreeSet.descendingSet(), TreeMap.descendingMap() - вернуть коллекцию в обратном порядке
	
	* Обзорная таблица TreeSet, TreeMap
		TreeSet
		■ ￼TreeSet.ceiling(e)			- Returns the lowest element >= e
		■ ￼TreeSet.higher(e)			- Returns the lowest element > e
		■ ￼TreeSet.floor(e)			- Returns the highest element <= e
		■ TreeSet.lower(e)			- Returns the highest element < e
		■ ￼TreeSet.pollFirst()		- Returns and removes the first entry
		■ ￼TreeSet.pollLast()			- Returns and removes the last entry
		■ ￼￼￼TreeSet.descendingSet()	- Returns a NavigableSet in reverse order
		
		TreeMap
		■ ￼TreeMap.ceilingKey(e)		- Returns the lowest key >= key
		■ ￼TreeMap.higherKey(e)		- Returns the lowest key > key
		■ ￼TreeMap.floorKey(e)		- Returns the highest key <= key
		￼■ TreeSet.lowerKey(e)		- Returns the highest key < key
		■ ￼TreeMap.pollFirstEntry()	- Returns and removes the first key-value pair
		■ ￼TreeMap.pollLastEntry()	- Returns and removes the last key-value pair
		■ ￼￼￼TreeMap.descendingMap()	- Returns a NavigableMap in reverse order
	
	* Backed Collections
		TreeMap<String, String> map = new TreeMap<String, String>();
		map.put("a", "ant"); map.put("d", "dog"); map.put("h", "horse");
		
		SortedMap<String, String> submap;
		submap = map.subMap("b", "g");					// #1 create a backed collection
		System.out.println(map + " " + submap);			// #2 show contents
		
		map.put("b", "bat");							// #3 add to original
		submap.put("f", "fish");						// #4 add to copy
		
		map.put("r", "raccoon");						// #5 add to original - out of range
		
		// submap.put("p", "pig");						// #6 add to copy - out of range
		System.out.println(map + " " + submap);			// #7 show final contents
		
		{a=ant, d=dog, h=horse} {d=dog}
		
		{a=ant, b=bat, d=dog, f=fish, h=horse, r=raccoon} {b=bat, d=dog, f=fish}
	
	* Если в submap положить то что выходит за границу выкинется Exception = java.lang.IllegalArgumentException: key out of range
		
		■  headSet(e, b*) 		Returns a subset ending at element e and exclusive of e
		■  headMap(k, b*) 		Returns a submap ending at key k and exclusive of key k
		■  tailSet(e, b*) 		Returns a subset starting at and inclusive of element e
		■  tailMap(k, b*) 		Returns a submap starting at and inclusive of key k
		■  subSet(s, b*, e, b*) Returns a subset starting at element s and ending just before element e
		■  subMap(s, b*, e, b*) Returns a submap starting at key s and ending just before key s
		
		Если не используется boolean то возвращается SortedSet/SortedMap
		Если используется boolean то возвращается NavigableSet/NavigableMap, а так же включаются границы в подгрупп
		
	* SortedMap/SortedSet не имеют pollFirst***() и pollLast***()
	
	* Если вставляется в subMap то это добавляется и в основной мап так как это ссылка на тотже мап
	
	* Типичная ситуация для экзамена когда вызывается на subMap или map - pollFirst*:
		 ■  удаляется для обоих если совпадают ключи
		 
		 {b=bat, d=dog, f=fish, h=horse, r=raccoon} {b=bat, d=dog, f=fish}
		 
		 map.pollFirstEntry();
		 
		 {d=dog, f=fish, h=horse, r=raccoon} {d=dog, f=fish}
		 
		 ■  не удаляется для обоих если не совпадают ключи
		 	{a=ant, b=bat, d=dog, f=fish, h=horse, r=raccoon} {b=bat, d=dog, f=fish}
		 	
		 	map.pollFirstEntry();
		 	
		 	{b=bat, d=dog, f=fish, h=horse, r=raccoon} {b=bat, d=dog, f=fish}
	
	* PriorityQueue - очередь с заданным приоритетом имеет конструкторы FIRST INPUT FIRST OUT
		■  PriorityQueue<E>(Collection<E> collection)
		■  PriorityQueue<E>(SortedSet<E> set)
		■  PriorityQueue<E>(PriorityQueue<E> set)
		■  PriorityQueue<E>(int initialCapacity)
		■  PriorityQueue<E>(int initialCapacity, Comparator<E>) - этим конструктором меняется приоритет
	
	* PriorityQueue - очередь с заданным приоритетом имеет следующие методы
		■  peek()		возвращает первый элемент
		■  poll()		возвращает первый элемент и удаляет его
		■  offer()		добавляет элемент в очередь
		■  element()		возвращает но не удаляет первый элемент очереди
		
Generic Types (Objectives 6.3 and 6.4)
	* На экзамене могут быть вопросы спрашивающие про Warnings
	
	* cast не нужен для Generics
	
	* javac -Xlint:unchecked - генерация warning где ошибка при компиляции
	
	* Не Generic коллекция всегда возвращает Object и никакого boxing unboxing  не проиходит
		List test = new ArrayList();	
		test.add(43);
		int x = (Integer)test.get(0);    // you must cast !!
		
		List<Integer> test2 = new ArrayList<Integer>();
		test2.add(343);
		int x2 = test2.get(0);           // cast not necessary
	
	* Обьявленному Generic типу должен присваиваться тот же самый тип polymorhism не работает
		List<Object> myList = new ArrayList<JButton>();  // NO!
  		List<Number> numbers = new ArrayList<Integer>(); // NO!
  		// remember that Integer is a subtype of Number
	
		// but there are fine
		List<JButton> myList = new ArrayList<JButton>(); // yes
  		List<Object> myList = new ArrayList<Object>();   // yes
  		List<Integer> myList = new ArrayList<Integer>(); // yes
	
	* Правила полиморфизма применяется только к базовым типам, а не к Generic
	 	Т.е. List -> ArrayList
	 		List<JButton> myList = new ArrayList<JButton>();
	 	
	 * Для массивов polymorphism работает
	 	import java.util.*;
  		
  		class Parent { }
  		class Child extends Parent { }
  
  		public class TestPoly {
      		public static void main(String[] args) {
          		Parent[] myArray = new Child[3];  // yes
			} 
		}

	* ? extends всегда и для интерфейсов и для классов
	
	* ? дает право на чтение
	
	* Без wildcard ? создание нового элемента в коллекции работает
		public class PolymorphicGeneric {
		public static void main(String[] args) {
			PolymorphicGeneric polymorphicGeneric = new PolymorphicGeneric();
			
			List<Cat> cats = new ArrayList<Cat>();
			cats.add(new Cat());
			polymorphicGeneric.addAnimal(cats); // This is now OK
		}
	
		public void addAnimal(List<? extends Animal> animals) { // Yes wildcard
			animals.add(new Dog()); // This is broken ??? WTF
		}}
	
		abstract class Animal {}
		class Dog extends Animal {}
		class Cat extends Animal {}
		
		//Но
		public class PolymorphicGeneric {
		public static void main(String[] args) {
			PolymorphicGeneric polymorphicGeneric = new PolymorphicGeneric();
			
			List<Cat> cats = new ArrayList<Cat>();
			cats.add(new Cat());
			polymorphicGeneric.addAnimal(cats); // Error
		}
	
		public void addAnimal(List<? extends Animal> animals) { // No wildcard
			animals.add(new Dog()); // still OK as always
		}}
	
		abstract class Animal {}
		class Dog extends Animal {}
		class Cat extends Animal {}		
	
	* есть еще wildcard super 
	  Если добавить public void addAnimal(List<? super Dog> animals) то все будет ок
	  Данная строчка позволяет добавлять супер типы в иерархии, ну и собственно сами типы
	   	List<Animal> newanimal - ОК
	   	animals.add(new Dog()); // OK
	
	* super делает доступным изменение коллекции
	
	* List<?> list - позволяет передавать в метод list любых элементов
		List<JButton> buttons = new ArrayList<Jbutton>(); -  работает
		// но
		
		void doInsert(List<?> list) { //Won't compile
      	 list.add(new Dog());
    	}
	
	* List<?> foo = new ArrayList<? extends Animal>(); - ошибка компиляции
		Нельзя использовать wildcard в создании, только в присвоении
		
	* List<? super Animal> dList = new ArrayList<Dog>(); - ошибка компиляции
	 Тип должен быть Animal или выше в иерархии (Object)

Generic Declarations
	* Пример декларирования Generic класса
		public class UseTwo<T, X> {
		    T one;
		    X two;
		    UseTwo(T one, X two) {
		      this.one = one;
		      this.two = two;
		    }
		    T getT() { return one; }
		    X getX() { return two; }
		  // test it by creating it with <String, Integer>
		    public static void main (String[] args) {
		      UseTwo<String, Integer> twos =
		                      new UseTwo<String, Integer>("foo", 42);
		      String theT = twos.getT(); // returns a String
		      int theX = twos.getX();   // returns Integer, unboxes to int
		    }
		}
		
	* Использование вместо ?
		public class AnimalHolder<T extends Animal> { // use "T" instead
		                                                // of "?"
		   T animal;
		   public static void main(String[] args) {
		     AnimalHolder<Dog> dogHolder = new AnimalHolder<Dog>(); // OK
		     AnimalHolder<Integer> x = new AnimalHolder<Integer>(); // NO!
		   }
		}

Creating Generic Methods
	* В методах <T> должен обязательно декларироваться до объявления возвращаемого типа
		public <T> void makeArrayList(T t)
  		
  	* Объявление типа в конструкторе реально 
  		public class Radio {
			public <T> Radio(T t) { }  // legal constructor
		}
		
	* class X { public <X> X(X x) { } } - это все круто
	
Inner Classes
	* Inner class компилируется в отдельный class файл с <именем родителя>$<имя inner класса>
	
	* Inner class не может иметь статических методов и переменных, переменные должны быть final или сам Inner class должен быть static
	
	* Inner class имеет доступ к private переменным класса родителя
	
	* Инстанцирование должно производиться после инициализации внешнего класса
	
	* Инстанцирование внутреннего класса вне внешего имеет следующий синтаксис
		InnerClasses ic = new InnerClasses();
		InnerClasses.Inner in = ic.new Inner();
		InnerClasses.Inner in = ic.     new Inner(); // All ok
		
	* this ссылается на inner класс
	
	* для ссылки на внешний класс используется <имя_внешнего_класса>.this
		MyOuter.this
	
	* Модификаторы доступа
		■ final
		■ abstract
		■ public
		■ private
		■ protected
		■ static—but static turns it into a static nested class not an inner class 
		■ strictfp

Method-Local Inner Classes	
	* В методе можно декларировать inner класс, но извне его использовать нельзя только там
	
	* Inner классы не могут использовать локальных переменных - это приводит к ошибке компиляции
		public void innerWiredDecalre() {
			int a = 10;
			class Inner2 {
				private void go(){
					System.out.println(a); // ошибка компиляции
				}
			}
		}
	
	* Inner классы в методах не могут быть private, public, protected, transient, static
	
	* Класс в методе может помечен или abstract или final
	
	* Inner класс в статическом методе работает по тем же правилам что и статические члены: не может обращаться к нестатическим переменным
		private Inner ic = new Inner();
		public static void innerWiredDecalre() {
			final int a = 10;
			class Inner2 {
				private void go() {
					System.out.println(ic); // Ошибка компиляции
				}
			}
		}
	
Anonymous Inner Classes
	* Анонимный класс как бы наследуется от своего суперкласса
	
	* Анонимный класс обязательно должен иметь в обяъявлении <имя_класса>() {};
	
	* Анонимный класс обязательно должен заканчиваться ";" иначе это ошибка 
	
	* К анонимному классу придъявляются все теже принципы на переопределение и на полиморфизм
	
	* Созданный метод в анонимном классе не может быть вызван извне класса
	
	* Создание ананимного класса из интерфейса работает
	
	* Анонимный класс можно создать прямо в методе
		class MyWonderfulClass {
			void go() {
			  Bar b = new Bar();
			  b.doStuff(new Foo() {
		    	public void foof() {
		      		System.out.println("foofy");
		    		} // end foof method
		  		}); // end inner class def, arg, and b.doStuff stmt.
			} // end go()
		 } // end class
 
		 interface Foo {
		   void foof();
		 }
			 class Bar {
		   void doStuff(Foo f) { }
		 } 
	
  	* В вызове метода обязательно должно быть }):
		} - закрывает анонимный класс
		) - закрывает вызов метода
		; - закрывает выражение
		
Static Nested Classes
	* static inner class 
		class BigOuter {
			static class Nested { }
		}
		
	* это значит к нему есть доступ как статическому члену без ссылки на внешний класс
	
	* Инстанцирование static inner class: BigOuter.Nest n = new BigOuter.Nest();   // both class names
	
	* На экзамене самая распространенная проблема это использование стического внутреннего класса с нестатическими переменными
	
Defining, Instantiating, and Starting Threads (Objective 4.1)
	* Для экзамена необходимо знать как миниму 4 метода:
		■  start()
  		■  yield()
  		■  sleep()
  		■  run()
  		
  	* Поток можно заставить выполняться 2мя способами:
  		■ Extend the java.lang.Thread class.
		■ Implement the Runnable interface.
		
	* При наследовании Thread нужно переопределить метод run() - плохо при проектировании так как Java поддерживает только единственное наследование 
	
	* Метод run можно переопределять, но это не вызовется в новом потоке с новым методом
		class MyThread extends Thread {
			public void run() {
				System.out.println("Important job running in MyThread");
			}
			public void run(String s) {
				System.out.println("String in run is " + s);
			} }
			
	* Если класс унаследовал Thread то инстанцирование очень простое
		MyThread t = new MyThread()
		
	* Если класс имплементирует Runnable то инстанцирование будет:
		MyRunnable r = new MyRunnable(); 	// Сначала экземпляр собственного класса
		Thread t = new Thread(r);			// Затем создать экземпляр класса Thread передав ему свой runnable код

	* В случае Runnable объект можно передать многим потокам, тем самым они будут выполнять одну и туже работу
		public class TestThreads {
		     public static void main (String [] args) {
		       MyRunnable r = new MyRunnable();
		       Thread foo = new Thread(r);
		       Thread bar = new Thread(r);
		       Thread bat = new Thread(r);
		} }
	
	* Класс Thread сам по себе имплементирует Runnable
		Thread t = new Thread(new MyThread()); // такая запись легальна
		
	* Класс Thread имеет следующие конструкторы
		■ Thread()
		■ Thread(Runnable target)
		■ Thread(Runnable target, String name) 
		■ Thread(String name)
		
	* До запуска Thread находится в состоянии new
	
	* После запуска start() поток переходит в состояние alive
	
	* После завершения run() поток переходит в death
	
	* Метод isAlive() предназначен для того чтобы узнать что поток был запущен но не завершен метод run()
	
	* Запуск потока t.start()
	
	* После вызова метода  start() происходит следующее:
		■ Начинается выполнение нового потока с новым call стеком
		■ Поток переходит из состояния new в состояние runnable
		■ Когда поток получает возможность выполнится он выполняет target метод run()
		
	* На экзамене встречается следующий код
		Thread t = new Thread();
		t.run();  // Legal, but does not start a new thread
		
	* Поток имеет имя которое можнополучить вызвав метод getName() у экземпляра, но экземпляр получить можно вызвав статический метод
		Thread.currentThread()
		Потоку можно установить имя t.setName("Fred");
		
		class NameRunnable implements Runnable {
			public void run() {
				System.out.println("NameRunnable running");
	         	System.out.println("Run by " + Thread.currentThread().getName());

			} }
		public class NameThread {
			public static void main (String [] args) {
				NameRunnable nr = new NameRunnable();
				Thread t = new Thread(nr);
				t.setName("Fred");
				t.start();
			} }
		
		// Вывод NameRunnable running
  		// Run by Fred
  	
  	* Если потоку не задать имя он все равно его получит вида 
  		Thread-0
  		
  	* Если вызвать имя потока в методе main то получим:
  		public class NameThreadTwo {
	     public static void main (String [] args) {
	       System.out.println("thread is " + Thread.currentThread().getName());
		} }
		// thread is main
	
	* Если запустить несколько потоков в цикле порядок выполнения не гарантирован
	
	* start() нельзя вызвать повторно породит RuntimeException: IllegalThreadStateException
	
	* у потока можно вызвать getld() - вернет положительный long 
	
The Thread Scheduler
	* scheduler часть JVM -он управляет состоянием потока
	
	* scheduler решает какой доступный поток выполнить - доступный поток это поток который находится в состоянии runnable
	
	* Методы класса java.lang.Thread
		public static void sleep(long millis) throws InterruptedException 
		public static void yield()
		public final void join() throws InterruptedException
		public final void setPriority(int newPriority)
		
	* InterruptedException - это checked Exception и оно должно отлавливаться
	
	* Методы класса java.lang.Object
		public final void wait() throws InterruptedException 
		public final void notify()
		public final void notifyAll()

Thread States and Transitions (Objective 4.2)
	* Поток может быть в 1м из 5ти состояний:
		■ New
			Состояния в котором прибывает поток после создания instance
		■ Runnable
			Состояние в котором поток готов к запуску и sheduler не выбрал его чтобы запустить. Поток входит в это состояние после вызова start()
			Поток так же может вернуться в это состояние после запуска или после sleeping, blocking, waiting
		■ Running
			Это состояние выполнение. Оно устанавливает после того как sheduler выбирает поток, из runnable пула потоков,
		■ Waiting/Blocking/Sleeping
			Это состояние когда поток isAlive() = true, но в данный момент не может быть выполнен. 
			В данном состоянии поток может вернуться в runnable состояние по наступления определенного события.
			Поток может быть блокирован ожидая завершения операции I/O. Поток может быть усыплен если в коде будет вызвана задержка.
			Или поток может быть в ожидании если код выполняющийся в потоке поставил его в ожидание.
			Важно что один поток не говорит заблокироваться другому. 
			Если есть ссылка на поток и будет вызван
				t.sleep();   or     t.yield()
			то это никак не повлияет на поток, только статические методы делаю это
		■ Dead
			Это состояние в которое поток переходит по окончанию метода run().
			Его нельзя больше запускать, но ссылка на него еще будет
	
Sleeping
	* статический метод в классе Thread sleep()
	
	* кидает checked Exception - InterruptedException
	
	* Если случится остановка во время того как поток sleeping то выбросится исключение InterruptedException

Thread Priorities and yield( )
	* приоритет потока обычно от 1 до 10
	
	* По умолчанию поток получает приоритет выполняемого потока в котором он создан
		public class TestThreads {
		    public static void main (String [] args) {
		      MyThread t = new MyThread();
		    }
		}
		// Приритет такой же как main
	
	* Установка приоритета
		FooRunnable r = new FooRunnable();
		Thread t = new Thread(r);
		t.setPriority(8);
		t.start();
	
	* JVM не меняет приоритета потока
	
	* Приоритет по умолчанию 5
		Thread.MIN_PRIORITY  (1)
		Thread.NORM_PRIORITY  (5)
		Thread.MAX_PRIORITY  (10)

	* Метод static Thread.yield() - метод не гарантировано переводит поток из runnig в runnable и дает потом одинакового с ним приоритета окно для работы
		Он никогда не переводит поток в waiting/sleeping/blocking
		
	* non-static join() класса Thread - позволяет одному потоку присоединяться в конец другого потока
	
	* Дан пример
		Thread t = new Thread();
  		t.start();
  		t.join();
  		
  		Берет текущий поток и присоединяет его в конец того который соответсвует ссылки t.
  		Это блокирует текущий поток от состояния перехода в runnable до того момента пока ссылка на поток жива
  		Это значит присоедени меня в конец потока t и t должен завершиться до того как я могу запустится еще раз
  		
  	* Перегруженная версия th.join(1000); - говорит о том что если это заняло больше 1000 мс то прекрати ждать
  	
  	* Следующие сценарии выводят поток из состояния running
  		■ метод run() заканчивается
  		■ Вызов wait() на объекте
  		■ поток не может получить lock на объект код которого запущен	
  		■ thread scheduler может решить перевести поток из состояния runnign в состояния runnable чтобы дать другим шанс на запуск
  		
Synchronizing Code (Objective 4.3)
	* Тейзисы о locking and synchronization:
		■ только метод или блок кода может быть synchronized
		■ каждый объект имеет 1 lock
		■ не все методы в классе должны быть synchronized
		■ если один поток вошел в synchronized  мето остальные ждут
		■ если класс имеет синхронизованные и не синхронизованные методы то множество потоков могут попрежнему обращаться к не синхронизованным методам
		■ если поток засыпает то он держит lock и не отпускает его
		■ поток может захватить несколько lock на разные объекты
		■ если поток получил lock а затем пытается вызвать тот же синхронизованный метод то ничего страшного поскольку JVM знает что lock у него
		■ можно синхронизовывать блоки кода
		
	* блок синхронизации должен иметь контекст
		 public void doStuff() {
		      synchronized(this) {
		          System.out.println("synchronized");
		      }
		}
		
	* static методы тоже могут быть synchronized
	
	* статический блок
		public static int getCount() {
			synchronized(MyClass.class) {
				return count;
			}
		}
		
	* Если поток не может получить lock на объект то он отправляется в wait pool, после того как lock будет освобожден не гарантируется отдача объекта конкретному потоку
	
	* Когда говорят о блокировках очень важно понимать какой объект получил используется для lock:
		■ Потоки вызывающие non static synchronized метод в том же классе блокируют друг друга если они вызываются используя один и тот же экземпляр
		■ Потоки вызывающие static synchronized методы в том же классе всегда будут блокировать друг друга - они лочат однин и тот же класс
		■ static synchronized метод и non static synchronized метод никогда не будут блокировать друг друга
		■ Для блоков синхронизации нужно ориентироваться на объекткоторый используется для lock
		
	* Методы и статус lock
		■ wait() отдает lock - java.lang.Object
		■ notify() не отдает lock, но после вызова вероятнее быстрее выдет из synchonized - java.lang.Object
		■ join() throws InteruptedException не отдает lock - java.lang.Thread
		■ static sleep() throws InteruptedException не отдает lock - java.lang.Thread
		■ static yield() не отдает lock - java.lang.Thread

Thread Deadlock
	* Пример deadlock

1	public class DeadlockRisk {
2		private static class Resource {
3			public int value;
4		}
5		private Resource resourceA = new Resource();
6		private Resource resourceB = new Resource();
7		public int read() {
8		  synchronized(resourceA) { // May deadlock here
9		    synchronized(resourceB) {
10		      return resourceB.value + resourceA.value;
11		    }
12		  }
13		}
14		public void write(int a, int b) {
15		  synchronized(resourceB) { // May deadlock here
16		    synchronized(resourceA) {
17		      resourceA.value = a;
18		      resourceB.value = b;
19			}
20   		  }
21		}
22     }
23	}

	* Одиночный поток не может входить в Deadlock

Thread Interaction (Objective 4.4)
	* wait(), notify(), and notifyAll() - должны быть вызваны в синхронизованном контектсе.
		Поток не может вызывать wait или notify методы на объект если не владет lock на этот объект 		
		
	* Пример
1 class ThreadA {
2	public static void main(String[] args) {
3		ThreadB b = new ThreadB();
4		b.start();
5		
6		synchronized (b) {
7			try {
8				System.out.println("Waiting for b to complete...");
9				b.wait();
10			} catch (InterruptedException e) {}
11			System.out.println("Total is: " + b.total);
12		}
13	}
14 }
15
16 class ThreadB extends Thread {
17	int total;
18	
19	public void run() {
20		synchronized (this) {
21			for (int i = 0; i < 100; i++) {
22				total += i;
23			}
24			notify();
25		}
26	}
27 }

	Для предотвращения завершения вызывается b.wait()
	Обязательно присутсвует контекст на b
	
	* Если поток не владеет lock и вызывает wait() то выбрасывается unchecked Exception - IllegalMonitorStateException.
	
	* wait(milleseconds) - имеет еще такую форму - это значит wait отпускает lock и ждет notify заданное время затем возвращается в runnable
	
	* wait - сразу отпускает lock
	
	* notify - если вызван это не значит поток отпусти lock прямо сейчас. Если поток выполняет synchronized код - lock не отпускается пока поток не
		выйдет из синхронизованного кода
		
	* Использование notifyAll позволяет оповестить сразу множество ждущих потоков
	
	* Хорошой практикой считается проверка какого либо значения в цикле прежде чем устанавливать wait()
	
	* notify() может вызываться thread scheduler для своихнужд
	
	* wait(), notify(), notifyAll() - принадлежат классу java.lang.Object
	
	* start(), static yield(), static sleep(), join() - принадлежат классу java.lang.Thread
	
	* run() - принадлежит интерфейсу Runnable
	
Using the javac and java Commands (Exam Objectives 7.1, 7.2, and 7.5)

	* Унифицированный синтаксис javac
		javac [options] [source files]
		
	* Легальные комманды
		javac -help
  		javac -classpath com:. -g Foo.java Bar.java // -g сгенерировать debug информацию, -classpath - путь
  		
  	* По умолчанию компилятор помещает скомпилированные файлы .class в туже директорию
  	
  	* опция -d говорит компилятору куда помещать сгенерированные .class файлы
  		javac -d classes source/MyClass.java // поместит MyClass.class в classes/MyClass.class
  	
  	* Если мы имеем структуру каталогов или пакеты то опция -d создаст недостающие директории
  		javac -d ../classes com/wickedlysmart/MyClass.java // поместит classes/com/wickedlysmart/MyClass.class
  		
  	* Если директория не существует то будет ошибка компиляции - No such file or directory
  	
  	* java команда для запуска 
  	
  	* Нужно помнить следующие опции
  		■ -ea -enableassertion - разрешение assertion
  		■ -da -disableassertion - запрещение assertion
  		■ -cp -classpath - путь для поиска
  		■ -D - опции

	* Структура комманды java
		java [options] class [args] // [args] и [options] необязательные
		
	* При вызове разрешение .class не добавляется
		java -DmyProp=myValue MyClass x 1 // свойство myProp=myValue запускается MyClass.class и передается 2 String аргумента x и 1
	
  	* java.util.Properties - класс который можно использовать для доступа к свойствам системы
		import java.util.*;
		  public class TestProps {
		    public static void main(String[] args) {
		      Properties p = System.getProperties();
		      p.setProperty("myProp", "myValue");
		      p.list(System.out);
		} }
		
		//call java -DcmdProp=cmdVal TestProps
		// Вывод будет содержать свойства cmdProp=cmdVal и myProp=myValue
		
	* properties.getProperty(key) - используется для получения свойства
		properties.getProperty(key, defaultValue) - значение по умолчанию используется если свойство не задано
	
	* после -D имя свойства должно идти без пробела
	
	* если значение свойства содержит пробелы оно должно помещаться в ""
		java -DcmdProp="cmdVal take 2" TestProps

	* метод main может декларироваться следующими способами
		■ static public void main(String[] args)
		■ public static void main(String... x)				//Начиная с Java 5
		■ static public void main(String bang_a_gong[]) 
	
Searching for Other Classes
	* javac и java используют один и тот же алгоритм поиска классов:
		■ Оба имеютодинаковые списки мест для поиска классов
		■ Оба осуществляют поиск по этому списку в одинаковом порядке
		■ Как только находят класс поиск останавливается. Если в списке находится больше одного то выбирается первый
		■ Первое место где смотрят это библиотеки J2SE
		■ Второе место это директории указанные в classpaths
		■ Classpaths - представляют собой список директорий в которых могут находится классы
		■ Существует 2 места где classpaths могут указываться:
			■ Classpath может указываться как environment variable операционной системы.
				Указанный здесь classpath используется по умолчанию в независимости от того вызывается java или javac
			■ Classpath может указываться как опция вызова коммандной строки в зависимости от команды javac или java.
			 * Сlasspath указанный как опция в коммандной строке переопределяет classpath задекларированный в переменной ос,
			 	но сохраняется только на время вызова
	
	* -classpath /com/foo/acct:/com/foo // разделитель :
		Данный classpath - привязан к операционной системе что указывает лидирующий / в начале
		В представленном примере директория над 2мя переменными такая как com не будет учавствовать в поиске
		
	* при поиске необходимо указать в classpath и сам файл для запуска и компиляции
		
	* точка . обозначает текущую директорию
	
	* /(root) или \. - абсолютный путь
	
	* относительный не начинается со /
	
JAR Files (Objective 7.5)
	* создание jar = jar -cf MyJar.jar myApp
	
	* просмотр содержимого jar = jar -tf MyJar.jar myApp
	
	* структура jar
		■ jar команда создает автоматически META-INF директорию
		■ jar команда создает автоматически файл MANIFEST.MF
		■ jar команда не помещает ни одного файла в META-INF/
		■ структура каталогов соответсвует запакованному
		■ java и javac используют jar как нормальную структуру папок
		
	* указание расширения jar обязательно
		javac -classpath ws/myApp.jar UseStuff.java
		
	* отличное место для jar jre/lib/ext - если поместить туда свой jar java и javac найдут его
	
	* Если на экзамене встретится JAVA_HOME or $JAVA_HOME - то это означает что: эта часть абсолютного пути до директорий указанный в явном виде

Using Static Imports (Exam Objective 7.1)
	* Примеры статического импорта
		import static java.lang.System.out;             // 1
        import static java.lang.Integer.*;
		public class TestStaticImport {
			public static void main(String[] args)  {
				out.println(MAX_VALUE);                     // 3
				out.println(toHexString(42));               // 4
		} }
	
	* Несколько правил по статическому импорту
		■ нужно использовать import static а не static import
		■ Нужно опасаться дублирования имен импортированных статических членов
			Если импортировать сразу Integer и Long то произойдет ошибка компиляции пересечение имен на MAX_VALUE
		■ Можно делать статический импорт на статические объектные ссылки, константы и методы
