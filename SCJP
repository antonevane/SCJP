Arrays
	* У массивов length это свойство
		String[] x = new String[3];
		System.out.println( x.length() ); // compiler error
		
	* ArrayStoreException кидается когда в массив передается объект не того типа, в основном это можно получить в случае полиморфизма
		public class PolymorphicArray {
		public static void main(String[] args) {
			arrayStoreException();
		}

		public static void arrayStoreException() {
			Animal[] catArr = new Cat[1];
			catArr[0] = new Dog();
		}}
		
		abstract class Animal {}
		class Dog extends Animal {}
		class Cat extends Animal {}
	
Boxing
	* Boolean, Byte, Character from \u0000 to \u007f (127), Short and Integer from -128 to 127 They are be =
	
		Integer i1 = 10;
		Integer i2 = 10;
		i1 == i2; // True
		
		Integer i1 = 128;
		Integer i2 = 128;
		i1 == i2; // False because > 127 but equals True
		long l = 128L;
		i1.equals(l) // Будет false
	 
	 
	 * Оболочные классы не могут быть расширены Bytes не может быть раширен до Short e.t.c
	 
	 * При overloading и autoboxing если просходит раширение до типа то проверяется IS-A
	
	 	class WidenAndBox {
	 		static void go(Long x) { System.out.println("Long"); }
            
            public static void main(String [] args) {
                    byte b = 5;
                    go(b); // must widen then box - illegal
			} 
		}
	
	* Here's a review of the rules for overloading methods using widening, boxing, and var-args:
		■ Primitive widening uses the "smallest" method argument possible.
		■ Used individually, boxing and var-args are compatible with overloading.
		■ You CANNOT widen from one wrapper type to another. (IS-A fails.)
		■ You CANNOT widen and then box. (An int can't become a Long.)
		■ You can box and then widen. (An int can become an Object, via Integer.)
		■ You can combine var-args with either widening or boxing.
	
	* такое возможно int[][] a = {{1,2,}, {3,4}};
	
Operators
	* операторы += *= делают cast
	
	* операторы *= *= работают на выражением справа
		int a *= 3 - 2
		 Это не a = 3*a - 
		 Это не a = a*(3-2)
		 
	* instanceof null всегда false
	
	* непрямая проверка instanceof true если супер класс имплеметирует интерфейс то и потомки неявно его имплеметирует
		interface Foo { }
		class A implements Foo { }
		class B extends A { }
		...
		A a = new A();
		B b = new B();
		
	  the following are true:
		a instanceof Foo
		b instanceof A
		b instanceof Foo // implemented indirectly
		
	* Нельзя проверять через instanceof 2 разные иерархии классов это Compilation Error
		class Cat { }
		class Dog {
			public static void main(String [] args) {
				Dog d = new Dog();
				System.out.println(d instanceof Cat);
			}
		}
	
	* Массивы это объекты они проверяются True
		if (nums instanceof Object) { } // result is true
	
	* операторы * , / и % имеют приоритет выше чем + и -
	
	* скобки имеют приоритет
	
	* При конкотенации строки если поставить скобки то будет вычисляться результат
		String a = "String";
		int b = 3;
		int c = 7;
		System.out.println(a + (b + c)); // Result is String37
		System.out.println(a + (b + c)); // Result is String10
		
	* Если слева строка производится конкатенация
		String s = "123";
		s += "45";
		s += 67;
		System.out.println(s); //1234567
	
	* инкрементное значение i++ - сначала присваивается потом увеличивается
	
	* Быть осторожным с ++ -- для final переменых
		final int x = 5;
		int y = x++;
		//and produces the error:
		Test.java:4: cannot assign a value to final variable x
		int y = x++;
				^
	
	* && and || используются только с булевыми операндами
		if (5 && 6) { } // Compilation error потому что 5 и 6 int
	
	* & и | - вычисляют обе части
	
	* ^ - вычисляет обе части. Если оба операнда одинаковые то значение false

Flow, Control, Exceptions, Assertions
	* УПС
		int y = 5;
		int x = 2;
		if ((x > 3) && (y < 2) | doStuff()) //Не напечатает так как используется короткая схема
		
		if (((x > 3) && (y < 2)) | doStuff()) //Все ок 2я часть вычисляется всегда и все ОК 
		{
			System.out.println("true"); //Не напечатает так как используется короткая схема
			}
		}

		static boolean doStuff() {
			return true;
		}
	
	* в if присвоение возможно только для Boolean и boolean, остальное compilation error
		boolean boo = false;
		if (boo = true) { } //Все ок даже присвоение проходит
		
		int x = 3;
		if (x = 5) { } // Won't compile because x is not a boolean!
		
	* switch проверяет char, byte, short, int, enum
	
	* в switch cast возможен
	
	* в метках switch можно использовать final переменные
		final short s =1;	
		int i = 1;
		
		switch (s) {
			case s:		All OK
				break;
		}
		
		//But,
		final short s;
		s =1;			
		int i = 1;
		
		switch (s) {
			case s:		//Compile error
				break;
		}
		
	* Одинаковые имена меток это Compile error
	
	* Если в выражение switch передать значение ниже int например byte,
		 и в метке указать значение больше значения типа то будет ошибка компиляции
	
		byte g = 2;
		switch(g) {
			case 23: 
			case 128: // 128 > разрешенных 127
		}
		
	* в switch case и : после метки обязательны
	
	* В switch char сравнивается как unicode
	
	* В switch при char работает и значение не unicode char и unicode char
				char c = '1';

		switch (c) {
			case 65535: //Legal last char
				System.out.println("1");
				break;

			case '\u0001': //Legal
				System.out.println("1"); 
				break;

			case 65536: 
				System.out.println("1"); //Compile error значение юольше разрешенного 65535 для char
				break;

			default:
				System.out.println("Default");
				break;
		}
		
		char c = '\u0001';
		
		switch (c) {
			case '\u0001':
				System.out.println("\u0001"); //Напечатается Юникод символ
				break;
		}

  Loops and Iterators (Exam Objective 2.2)
	* В блоке увеличения переменной может быть печать, анонимное создание класаса и т п
		int d = 3;
		for (int a = 1; d != 1; System.out.println("iterate")) {
			d = d - a;
		}

		int b = 3;
		for (int a = 1; b != 1; new String()) {
			b = b - a;
		}
		
		//Но
		int b = 3;
		for (int a = 1; b != 1; {new String()}) { // ошибка из за {}
			b = b - a;
		}
		
	* continue - используется только в циклах
	
	* break - используется в циклах и switch
	
	* Метка должна предворять цикл или иметь {} в случае наличия выражение перед ней
	
		label: //All OK 
			for (int i = 0; i < args.length; i++) {
				System.out.println("InLOOP");
				break label;
			}

		// Но ошибка если что то есть
		label: //Compile error
			System.out.println("Before Loop");
			for (int i = 0; i < args.length; i++) {
				System.out.println("InLOOP");
				break label;
			}
			
		// Но нет ошибки если есть {}
		label: { //OK
			System.out.println("Before Loop");
			for (int i = 0; i < args.length; i++) {
				System.out.println("InLOOP");
				break label;
			}
		}
		
Handling Exceptions (Exam Objectives 2.4 and 2.5)
	* Иерархия классов Exception
		Object
		  |
	   Throwable
	    |	   |
	 Error    ____Exception______
	 |		|					|
Others... RuntimeException	 Others... 

	* Если в коде выбрасывается исключение и оно checked то будет compile error
		
		//Fail IOException нужно задекларировать
		public void doStuff() {
			try {
				// risky IO things
			} catch(IOException ex) {
				// can't handle it
				throw ex; // Can't throw it unless you declare it
			}
		}
	
	* finally может не вызваться если в try или catch вызван System.exit()  
		
Common Exceptions and Errors (Exam Objective 2.6)
	*Throw JVM
		ArrayIndexOutOfBoundsException
		ClassCastException
		NullPointerException
		ExceptionInInitializerError
		StackOverflowError
		NoClassDefFoundError
	
	*throw Programmatically
		IllegalArgumentException
		IllegalStateException
		NumberFormatException
		AssertionError

Working with the Assertion Mechanism  (Exam Objective 2.3)
	*Валидное использование Assertion
		int x = 1;
		boolean b = true;
		int aReturn() { return 1; }
		
		assert(x == 1);
		assert(b);
		assert true;
		assert(x == 1) : x;
		assert(x == 1) : aReturn();
		assert(x == 1) : new ValidAssert();
		
	*Невалидное использование Assertion
		void noReturn() { }
		
		assert(x = 1); // none of these are booleans
		assert(x);
		assert 0;
		assert(x == 1) : ; // none of these return a value
		assert(x == 1) : noReturn();
		assert(x == 1) : ValidAssert va;
		
	* До версии 1.4 слово assert можно использовать как идентификатор
		int assert = getInitialValue();
		if (assert == getActualResult()) {
			// do something
		}
	  
	  Если использовать компиляцию для 1.6 будет ошибка, 
	  но можно сделать javac -source 1.3 OldCode.java - все ок хотя если использовать assert как ключевое слово то это ошибка
	  
	 * 2 опции для включения компиляторов 5,6 
	 	-source 1.6 or -source 6
	 	-source 1.5 or -source 5
	 
	 * Компиляция под разные версии JVM
	 	javac -source 1.3 TestAsserts.java
	 	javac -source 1.4 TestAsserts.java
	 	javac -source 1.5 TestAsserts.java
	 	javac -source 5 TestAsserts.java
	 	javac -source 1.6 TestAsserts.java
	 	javac -source 6 TestAsserts.java
	 
	 * Включение assertion в runtime
	 	java -ea com.pack.TestClass
	 	java -enableassertions com.pack.TestClass
	 	
	 * Выключение assertion в runtime
	 	java -da com.pack.TestClass
	 	java -disableassertions com.pack.TestClass
	 	
	 * Частичное исключение классов
	 	java -ea -da:com.geeksanonymous.Foo Test
	 	
	 * Частичное исключение пакетов
	 	java -ea -da:com.geeksanonymous...
	 	
	 * Tricky assertion
	 	java -ea -dsa Enable assertions in general, but disable assertions in system classes.

Using Assertions Appropriately (По конвеции Sun)
	 * Inappropriate использовать assertion для валидации аргументов в public методах
		 public void doMore(int x) {
			assert (x > 0);
			// do things with x
		}
	 * Inappropriate использовать assertion для валидации аргументов командной строки
	 * Inappropriate использовать assertion для изменения логики работы программы, при вызове assertion и без него логика остается таже
	 	public void doStuff() {
			assert (modifyThings());
			// continues on
		}
		
		public boolean modifyThings() {
			y = x++;
			return true;
		}
	 
	 * Appropriate использовать assertion для валидации аргументов в private методах
	 	private void doMore(int x) {
			assert (x > 0);
			// do things with x
		}
	
	* Appropriate использовать assertion для кода который точно никогда не выполнится даже в public методах
		switch(x) {
			case 1: y = 3; break;
			case 2: y = 9; break;
			case 3: y = 27; break;
			default: assert false; // we're never supposed to get here!
		}

Strings
	* Создание строк генерирует разное число объектов
		String s = "abc"; // creates one String object and one 
							// reference variable
		// В этом случае "abc" отправляется в pool и создается ссылка s 
		
		String s = new String("abc"); // creates two objects, 
										// and one reference variable
		//В этом случае создается объект в обычной памяти, создается ссылка, а также "abc" помещается в пул				
		
	* Методы которые встречаются на экзамене
		■  public charAt(index) 				Returns the character located at the specified index
		■  public concat(string)				Appends one String to the end of another ( "+" also works)
		■  public equalsIgnoreCase(string) 		Determines the equality of two Strings, ignoring case
		■  public length() 						Returns the number of characters in a String
		■  public replace(char, replaceChar)	Replaces occurrences of a character with a new character
		■  public substring(startPos) 			Returns a part of a String
		■  public substring(startPos, endPos)	Returns a part of a String
		■  public toLowerCase() 				Returns a String with uppercase characters converted
		■  public toString() 					Returns the value of a String
		■  public toUpperCase() 				Returns a String with lowercase characters converted
		■  public trim() 						Removes whitespace from the ends of a String
	
	* У строк length это метод
		String x = "test";
		System.out.println( x.length ); // compiler error
		
	* substring() в Java хитрый
		String x = "0123456789"
		System.out.println( x.substring(5) ); // output is "56789"
		System.out.println( x.substring(5, 8)); // output is "567"
		//Во втором случае с 5го индекса и до 8го индекса или до 7го включительно
		
StringBuffer, StringBuilder
	* Методы которые встречаются на экзамене для StringBuffer (для StringBuilder они not sychronized)
		■  public synchronized StringBuffer append(String s) - This method will take many different arguments, including boolean, char, double, float, int, long, and other
			StringBuffer sb = new StringBuffer("set ");
			sb.append("point");
			
		■  public StringBuilder delete(int start, int end)
			StringBuilder sb = new StringBuilder("0123456789");
			System.out.println(sb.delete(4,6)); // output is "01236789"
			
		■  public StringBuilder insert(int offset, String s)
			StringBuilder sb = new StringBuilder("01234567");
			sb.insert(4, "---");
			System.out.println( sb ); // output is "0123---4567"
			
		■  public synchronized StringBuffer reverse()
			StringBuffer s = new StringBuffer("A man a plan a canal Panama");
			sb.reverse();
			System.out.println(sb); // output: "amanaP lanac a nalp a nam A"
			
		■  public String toString()

File Navigation and I/O (Exam Objective 3.2)
	* I/O Классы для экзамена
		■  File - абстрактное представление файла и директорий с путями до них 
		
		■  FileReader - класс для чтения символа из файла. Метод read() - читает один символ. Читает потоки символов. Фиксированный набор символов.
			FileReader - обычно оборачивают Высокоуровнемы классами Reader, таким как BufferedReader - который улучшает производительность засчет буфферизации 
			и предоставляет более удобные способы для работы с данными
		
		■  BufferedReader - lower-level Reader. В сравнении с FileReader считывает относительно большие куски данных из файла и помещает в буфер.
			Когда запашиватся символ или строка данных они достаются из буфера - это уменьшает количество обращений к файлу тем самым увеличивается
			производительность.
			Кроме того BufferedReader предоставляет более удобные, по сравнению с FileReader методы например readLine() - считывает следующую строку из файла 
		
		■  FileWriter - используется для записи символа в файл. Его методы write() позволяют записывать: символ(ы), или строки в файл.
			FileWriter обычно оборачивают Высокоуровнемы классами Writer таким как BufferedWriter или PrintWriter, которые предоставляю лучшую производительность 
			и более удобные методы для записи данных в файл.
			
		■  BufferedWriter - используется для высокоуровнего представления классов таких как FileWriter. В сравнении с FileWrite записывает относительно большие куски данных
			 порциями, тем самым уменьшая количество тяжелых операций записи.
			 BufferedWriter предоставляет удобные методы для записи в файл, например newLine() - автоматически создает платформенно специфичный символ новой строки
			 
		■  PrintWriter - самый мощный и доработанный класс
		
		■  Console - класс для работы с консолью

	* Обязательно нужен import java.io.*;
	
	* new File("fileWrite1.txt") не создает еще файл
		newFile = file.createNewFile() - создает файл или ссылку на существующий возвращает boolean
		System.out.println(file.exists());  // look for a real file
		
	* createNewFile() создает новый файл только если он не существует
	
	* FileWriter - нужно делать flush() и close()
	
	* FileWriter fw = new FileWriter(file); // Физически создает файл
	
	* FileReader - read(char [] buffer), обязательно нужно закрывать
	
	* Reader не иммет Flush
	
	* File - имеет метод по созданию директории mkDir()
	
	* File - можно привезать и к директории File(File директория, String имя_файла)
	
	* Если не создать директорию вызвав метод но передать в конструктор то будет ошибка java.io.IOException: No such file or directory
	
	* метод delete() у класса File не может удалить директорию если она не пустая
	
	* renameTo() - выбросит NullPointerEception если передать null в имя нового файла
	
	* Для поиска файла используется метод String [] search()
		String[] files = new String[100];
		File search = new File("searchThis");
		files = search.list();
		
java.io.Console Class
	* System.console() - возвращает ссылку на физическую консоль, невозможно использовать если нет доступа

	* char[] readPassword - возвращает набор символов чтобы не быть помещенным в StringPool
	
	* Получение консоли Console c = System.console();
	
	* pw = c.readPassword("%s", "pw: "); - 1й параметр формат 2й приветствие
	
	* c.format("%c", char_) - форматированный вывод
	
Serialization (Exam Objective 3.3)
	* ObjectOutputStream.writeObject() // serialize and write
	
	* ObjectInputStream.readObject() // read and deserialize
	
	* Обязательно должен быть имплеменирован интерфейс Serializable
	
	* Все классы которые ссылаются на сериализованный объект должны быть Serializable
	
	* Если нет возможности сохранить класс то можно пометить его transient
	
	* readObject бросает ClassNotFoundException
	
	* Для того чтобы обойти ограничение несериализуемого объекта можно создать 2 метода для управления процессом сериализации:
		private void writeObject(ObjectOutputStream os){
			// throws IOException { // 1
			try {
				os.defaultWriteObject();// 2
				os.writeInt(theCollar.getCollarSize()); // 3 
			} catch (Exception e) { e.printStackTrace(); }
		}
		
		private void readObject(ObjectInputStream is) {
			// throws IOException, ClassNotFoundException { // 4 
			try {
				is.defaultReadObject();// 5 
				theCollar = new Collar(is.readInt()); // 6
			} catch (Exception e) { e.printStackTrace(); }
		}
	
	* Порядок чтения должен быть таким же как и при записи в случае записи дополнительного кода : os.writeInt(int)
	
	* При сериализации коллекций и массивов - все их элементы должны быть Serializarble
	
	* Object не Serializable
	
	* static не сериализуются потому что принадлежат классу
	
Inheritance and Serialization
	* В случае если супер класс не Serializable, а потомок да то при восстановление унаследованная часть будет переинициализирована
		
		!!!!!Конструктор запустится заново!!!
		
		class Animal {
			public String name;
		}
		class Dog extends Animal implements Serializable {
			// the rest of the Dog code
		}
	
Dates, Numbers, and Currency (Exam Objective 3.4)
	* На экзамене необходимо понимать следующие классы
		■  java.util.Date
		■  java.util.Calendar
		■  java.util.Locale
		■  java.text.DateFormat
		■  java.text.NumberFormat
	
	* Типичные операции
		■  Получить текущую дату и время
			Date d = new Date();
			String s = d.toString();
			
		■  Получить объект позволяющий выполнять операции с датой и временем в вашей локале
			Calendar c = Calendar.getInstance();
			c.add(...)
			c.rool(...)
			
		■  Получить объект позволяющий выполнять операции с датой и временем в различной локале
			Locale loc = new Locale(language);or
			Locale loc = new Locale(language, country);
			
			Calendar c = Calendar.getInstance(loc);
			c.add(...)
			c.rool(...)
			
		■  Получить объект позволяющий выполнять операции с датой и временем в различной локале и применить форматировый вывод в разных стилях
			Calendar c = Calendar.getInstance();
			Locale loc = new Locale(...);
			Date d = c.getTime();
			DateFormat df = DateFormat.getDateInstance(style, loc);
			String s = df.format(d);
			
		■  Получить объект позволяющий выполнять форматирование цифр и валют в различных локалях
			Locale loc = new Locale(...);
			NumberFormat nf = NumberFormat.getInstance(loc);
				-or- NumberFormat nf = NumberFormat.getCurrencyInstance(loc);
			String s = nf.format(someNumber);
	
	* Calendar зависит от локали - Calendar.SUNDAY == c.getFirstDayOfWeek() - проверка дня недели в Англии это Sunday в России Monday
	
	* Calendar абстрактный класс, но имеет статический инициализатор который инстанцирует календарь
	
	* Calendar.getInstance() - инициализируется текущим временем
	
	* В календаре месяц при установке начинается с 0
		Calendar c = Calendar.getInstance();
		c.set(2010, 11, 14); // December 14, 2010
	
	* calendar.add(field, amount) - добавляет значение если не указать отрицательное число
	
	* roll - метод для увеличения или умньшения части даты, но не позволяет перейти границу значения
		// assume c is October 8, 2001
		c.roll(Calendar.MONTH, 9); // notice the year in the output
		Date d4 = c.getTime();
		System.out.println("new date " + d4.toString() ); //new date Fri Jul 08 19:46:40 MDT 2001
	
	* DateFormat - абстрактный класс со следущими статическими инициализаторами
		DateFormat.getInstance();                      //9/8/01 7:46 PM
		DateFormat.getDateInstance();                  //Sep 8, 2001 По умолчанию используется MEDIUM
		DateFormat.getDateInstance(DateFormat.SHORT);  //9/8/01
		DateFormat.getDateInstance(DateFormat.MEDIUM); //Sep 8, 2001
		DateFormat.getDateInstance(DateFormat.LONG);   //September 8, 2001
		DateFormat.getDateInstance(DateFormat.FULL);   //Saturday, September 8, 2001
		
		String df.format(дата)
		Date df.parse(String)
	
	* DateFormat и NumberFormat - не меняют локали в runtime это ошибка компиляции 
	
	* Класс Locale 2 конструктора и 1 статический инициализатор
		Locale defaultLocale = Locale.getDefault();
		Locale locPT = new Locale("it"); // Italian
		Locale locBR = new Locale("it", "CH"); // Switzerland
	
	* Класс Locale методы
		Locale locBR = new Locale("pt", "BR"); // Brazil
		System.out.println("def " + locBR.getDisplayCountry());      //Brasil
		System.out.println("loc " + locBR.getDisplayCountry(locBR)); //Brasil
		
	* Класс NumberFormat абстрактный со следующими статическими инициализаторами
		Locale locFR = new Locale("fr");
		NumberFormat.getInstance();				//123.457
		NumberFormat.getInstance(locFR);		//123.457
		NumberFormat.getCurrencyInstance();		//$123.46
		NumberFormat.getCurrencyInstance(loc);	//123,46 ?
		
	* Вызов NumberFormat format(число)	
	
	* По умолчанию количество цифр после запятой 3
		float f = 10.1126f;
		NumberFormat fn = NumberFormat.getInstance();
		System.out.println(fn.getMaximumFractionDigits());	//Выведет 3
		System.out.print(nf.format(f1) + " "); 				//Выведет 10,113
		// Можно расширить
		fn.setMaximumFractionDigits(5);
		System.out.print(nf.format(f1) + " "); 				//Выведет 10,1126
		fn.parse("1234.567") // Бросает ParseException и Возвращает Number - который абстрактный и реализуют оболочки примитивных типов
		fn.setParseIntegerOnly(true); //Задает парсинг только integer
		
		fn.parse("1234.567") //Выводит 1234
		
Parsing, Tokenizing, and Formatting (Exam Objective 3.5)
	0[xX]([0-9a-fA-F])+ - поиск всех 16ти ричных 
	
	* Необходимые импорты
		java.util.regex.Pattern
		java.util.regex.Matcher
	
	* Патерны Regex
		\d - цифры
		\s - пробелы
		\w - слова (буквы, цифры, '_')
		[a-z] - группа
		+ 1 или более
		* - 0 или более
		? - 0 или 1
		^ - отрицание [^abc] - кроме a b c
		. - любой сомвол
		*? , ??, +? - работают для всего выражения с права на лево
		
	
	* Mathcher matcher = pattern.matcher() - получение matcher
		matcher.find() - осуществляет поиск
		matcher.group() - возвращает искомую подстроку
		matcher.start() - возвращает индекс искомой подстроки
	
	* tricky: 
		source: yyxxxyxx
		pattern: .*xx
		result: yyxxxyxx
		
		source: yyxxxyxx
		pattern: .*?xx или .+?xx 
		result: 
			'yyxx'
			'xyxx'
		
		source: yyxxxyxx
		pattern: .??xx
		result: 
			'yxx'
			'yxx'
	
	* Ошибки компиляции
		String pattern = "\d"; // Одиночный \ нужно \\d
			
	* Проверка нулевой строки происходит в regex
		source = "aba"
		pattern = "a?";
		Вызов m.end()
		
		0 1 a
		1 1
		2 3 a
		3 3
		
		Происходит в следующих случаях:
			После последнего символа в строке
			В начале строки
			Между символами после найденного символа
			В начале строки нулевой длинны
	
	* Поиск с помощью класса Scanner
		Scanner s = new Scanner(System.in);
		s.findInLine(args[0])
		
Tokenizing
	* split() и Scanner
	
	* Scanner default delimeter is ' '
	
	* Scanner работает со строками, файлами, потоками
	
	* Токены сканера могут быть автоматически сконвертированы в примитивные типы
	
	*Scanner имеет следующие методы для получения данных
		String next()
		<Type> nextXXX() - <Type> - Boolean, Byte, Short, Integer, Double, Float, BigInteger, BigDecimal
		
		# Кроме char
		
	*Scanner имеет следующие для проверки
		Boolean hasNext()
		Boolean hasNextXXX()
		
	*Scanner может устанавливать локаль и делимитр систему счисления
		scanner.useDelimiter(pattern)
		scanner.useLocale(locale)
		scanner.useRadix(radix) 
	
	* Маска printf
		%[arg_index$][flags][width][.precision]conversion char
		
		arg_index - индекс параметра
		flag:
			■ "-" Left justify this argument
			■ "+" Include a sign (+ or -) with this argument
			■ "0" Pad this argument with zeroes
			■ "," Use locale-specific grouping separators (i.e., the comma in 123,456)
			■ "(" Enclose negative numbers in parentheses
		width - минимальная длина колонки для распечатывания
		precision - точность только для чисел с плавающей точкой
		conversion - тип конверсии:
			■  b boolean
			■  c char
			■  d integer
			■  f floating point
			■  s string
		
		int i1 = -123;
		int i2 = 12345;
		System.out.printf(">%1$(7d< \n", i1); 				// > (123)<
		System.out.printf(">%0,7d< \n", i2);				// >012,345<
		System.out.format(">%+-7d< \n", i2);				// >+12345 <
		System.out.printf(">%2$b + %1$5d< \n", i1, false);	// >false + -123<
		
	* Ошибки компиляции при указании format
		System.out.format("%d", 12.3); - ошибка компиляции
		
Overriding hashCode() and equals() (Objective 6.2)
	* На экзамене попадаюся примеры на правила переопределения а не на equals
		 public boolean equals(Boo b) { } // Compiler error
		 
The equals() Contract
	* Рефлексия.
		It is reflexive. For any reference value x, x.equals(x) should return true.
		Car car = new Car();
		car.equal(car);	// Должно быть true
	
	* Симментрия.
		It is symmetric. For any reference values xand y, x.equals(y) should 
			return true if and only if y.equals(x) returns true.
		Car x = new Car();
		Car y = new Car();
		
		x.equal(y);	// Должно быть true 
		//если
		y.equal(x);	// Должно быть true

	* Транзитивность.
		For any reference values x, y, and z, if x.equals(y) returns 
	true and y.equals(z) returns true, then x.equals(z) must return true.
		Car x = new Car();
		Car y = new Car();
		Car z = new Car();
		
		x.equal(y);	// Если true 
		y.equal(z);	// Если true
		//то
		x.equal(z);	// Должно быть true

		
	* Консистентность.
		 It is consistent. For any reference values xand y, multiple invocations of 
		x.equals(y) consistently return true or consistently return false, pro-vided no information used in equals comparisons on the object is modified.

		Car x = new Car();
		Car y = new Car();
		
		x.equal(y);	// Должно быть true
		x.equal(y);	// Должно быть true
		x.equal(y);	// Должно быть true
		x.equal(y);	// Должно быть true всегда вне зависимости от количества вызовов
		
	* Для не пустой ссылки x вызов x.equals(null) должно быть false
	
	
Overriding hashCode()
	* От вызова к вызову int значение hasCode() не должено меняться
	
	* Два эквивалентных объекта должны иметь одинаковое int значение hashCode()
	
	* Не обязательно у неэквивалентных объектов должено быть разное значение hasCode()
	
	* transient поля нежелательно использовать при формировании hashCode(): 
		В случае десиарилизации они заполнятся значениями по умолчанию

Collections (Exam Objective 6.1)
	* Core интерфейсы:
		■  Collection 
		■  Set 
		■  SortedSet
		■  List 
		■  Map 
		■  SortedMap
		■  Queue 
		■  NavigableSet 
		■  NavigableMap
		 
	* Конкректные имплементации классов
		■  Maps:
			HashMap
			Hashtable
			TreeMap
			LinkedHashMap

		■  Sets:
			HashSet
			LinkedHashSet
			TreeSet

		■  Lists:
			ArrayList
			Vector
			LinkedList

		■  Queues:
			PriorityQueue
			
		■  Utilities:
			Collections
			Arrays
	
	* java.util.Collections - это утилитный класс содержащий полезные методы
		 add(), remove(), contains(), size(), and iterator()  

Ordered(Упорядоченные)
	* ArrayList - упорядочен по индексу
	
	* LinkedHashSet - упорядочен порядку вставки элемента

Sorted(Отсортированные)	
	* LinkedHashSet - упорядочен порядку вставки элемента

List Interface
	* ArrayList
		Упорядоченная по позиции индекса
		Быстрый доступ
		Не отсортирована
		Реализует RandomAccess
		+ получение элемента приблизительно константное время, быстрый обход
		- Медленная вставка и удаление
		не synchronized		
	
	* Vector
		synchronized
		Реализует RandomAccess
		Остальное такое же как и у ArrayList
	
	* LinkedList
		Упорядоченная по позиции индекса
		элементы 2-ды связаны между собой
		добавляет методы удаления из начала и конца (хороший выбор для реализации Стэка и Очереди)
		+ быстрая вставка и удаление
		- медленный доступ чем ArrayList
		имплементирует Queue : peek(), poll(), and offer()
		Реализует RandomAccess
		Остальное такое же как и у ArrayList
		не synchronized	
		
Set Interface
	* HashSet
		не содержит дубликатов
		не упорядочена и не отсортирована
		производительность доступа к данным зависит от реализации hashCode()
		обязательное переопределение hashCode()
		не synchronized
	
	* LinkedHashSet
		упорядоченная в порядке вставки
		2 связный список
		обязательное переопределение hashCode()
		производительность доступа к данным зависит от реализации hashCode()
		не synchronized
		
	* TreeSet
		1 из 2х отсортированных коллекций
		Red-Black tree structure - отсортирована в порядке возрастания (в натуральном порядке)
		имплементирует NavigableSet
		Правила сортировки можно солздать свой через Comparable or Comparator
		не synchronized
		
Map Interface
	* HashMap
		не упорядочена и не отсортирована
		производительность доступа к данным зависит от реализации hashCode()
		Можно вставлять null для ключа
		Можно вставлять null для значения
		не synchronized
	
	* Hashtable
		synchronized
		Нельзя вставлять null для ключа
		Нельзя вставлять null для значения
		
	* LinkedHashMap
		упорядоченная в порядке вставки
		2 связный список
		обязательное переопределение hashCode()
		производительность доступа к данным зависит от реализации hashCode()
		- Медленнее HashMap на вставку и удаление
		+ быстреее итерирование
		не synchronized
		
	* TreeMap
		Red-Black tree structure - отсортирована в порядке возрастания (в натуральном порядке)
		имплементирует NavigableSet
		Правила сортировки можно солздать свой через Comparable or Comparator
		не synchronized	
	
Queue Interface (FIFO (first-in, first-out))
	* PriorityQueue
		Новый начиная с Java 1.5
		используется для организации очереди "priority-in, priority out"
			 - элементы упорядочены или в естественном порядке или в соответсвии с Comporator
		Упорядочевание элементов представляет их приоритет
		
	*Таблица на странице 565

Using the Collections Framework (Objectives 6.3 and 6.5)
	* в ArrayList есть метод удаления по значению который удаляет элемент с наименьшим индексом
	
	* Сортировка для List<String> stuff; Collections.sort(stuff);
	
	* Если поместить в List собственный объект без добавления Comparable то будет ошибка
	
	* String реализует Comparable<String>
	
	* Comparable interface используется Collections.sort() и java.util.Arrays.sort() для сортировки коллекци и массивов
	
	* Для реализации Comparable нужно реализовать метод compareTo() соответсвующий следующим характеристикам:
		■ negative 		If thisObject < anotherObject
		■ zero 			If thisObject == anotherObject
		■ positive 		If thisObject > anotherObject
	
	* Comparable<Тип>
		obj1.compareTo(obj2)
		
	* Comparable применяется к текущему классу
	
	* Comparable предполагает только 1 вид сортировки
	
	* Имплементирую String, Wrapper classes, Date, Calendar....
	
	* Интерфейс Comparator<тип> используется для организации любой сортировки, содержин метод 
		int compare(тип объект1, тип объект2)
	
	* В Collections есть перегруженный метод sort() принимающий как 2й параметр Comparator
		Collections.sort(list, ownComparator)
		
	* Comparator отдельный класс
	
	* Объекты разных классов не могут быть отсортированы
	
	* Comparator предполагает только n вид сортировки
	
	* Класс Arrays содержит
		■  Arrays.sort(arrayToSort)
		■  Arrays.sort(arrayToSort, Comparator)		
	
Searching Arrays and Collections
	* Поиск осуществляется с помощью binarySearch()
		binarySearch(<массив/коллекциa>, элемент для поиска)
		binarySearch(<массив/коллекциa>, элемент для поиска, comporator)
	
	* успешный поиск возвращает индекс элемента (0 тоже индекс)
	
	* Неуспешный возвращает так называемую insertion point = (-(insertion point) -1)
	
	* Коллекция или массив должны быть отсортированы перед поиском
	
	* Если не отсортировать то поиск будет не предсказуемый
	
	* Если массив или коллеция отсортированы в естественном порядке то и поиск будет осуществляться в естественном порядке
		(Обычно это достигается вызовом метода без компоратора)
	
	* Если коллеция была отсортирована компоратором то и поиск должен осуществляться с этим же компоратором
	
	* Компаратор не может быть использован при сортировки простых типов
	
	* На экзамене при решении вопросов на сортировки есть 2 засадных момента:
		■  Поиск по массиву/коллекции которые не были отсортированы
		
		■  Использовании компоратора только или на сортировке или на поиске но не вместе
	
	* Collection содержит методы возвращающие компратор
		■  static Comparator reverseOrder()				- возвращает компаратор который сортирует в обратном порядке
		■  static Comparator reverseOrder(Comparator)	- возвращает компаратор который сортирует в обратном порядке
	
	* Arrays.asList(Object ...) 
	
	* если менять значения в листе или массиве они изменятся в обоих
	
	* list.toArray() - может возвращать либо Object [] либо Тип []
	
	* Iterator вызывается у коллекций list.iterator()
	
	* hasNext() говорит о том есть ли еще элемент
	
	* только next() передвигает итератор
	
	* В Set уникальные элементы
	
	* если в Set через: boolean add() добавить дублика то результатом вернется false
	
	* Set remove(object) - метод для удаления элемента
	
	* Set имеет toArray()
	
	* HashSet как правило очень быстрый так как он использует hashCode()
	
	* TreeSet это Set где элементы отсортированы
	
	* При использовании TreeSet все элементы должны быть одного типа если нет то будет ClassCastException в runtime
	
	* Чем уникальнее hashCode() тем быстрее Map
	
	* В Map hashCode() - используется для поиска корзины
			equals() - используется для поиска значения
			
Navigating (Searching) TreeSets and TreeMaps
	* java.util.NavigableSet
	 	lower()  	return less
	 	floor()  	return less or equal
	 	higher() 	return high 
	 	ceiling() 	return high or equal
	 
	 * java.util.NavigableMap
	 	lowerKey()  	return less
	 	floorKey()  	return less or equal
	 	higherKey() 	return high 
	 	ceilingKey() 	return high or equal
	
	* Pool значит retrive and remove
	
	* TreeSet
		pollFirst()	- получить и удалить первый элемент
		pollLast()	- получить и удалить последний элемент
	
	* TreeMap
		pollFirstEntry()	- получить и удалить первую пару ключ-значение
		pollLastEntry()		- получить и удалить последнюю пару ключ-значение
		
	* TreeSet.descendingSet(), TreeMap.descendingMap() - вернуть коллекцию в обратном порядке
	
	* Обзорная таблица всех методов для Navigation p. 588
	
	* Backed Collections
		TreeMap<String, String> map = new TreeMap<String, String>();
		map.put("a", "ant"); map.put("d", "dog"); map.put("h", "horse");
		
		SortedMap<String, String> submap;
		submap = map.subMap("b", "g");					// #1 create a backed collection
		System.out.println(map + " " + submap);			// #2 show contents
		
		map.put("b", "bat");							// #3 add to original
		submap.put("f", "fish");						// #4 add to copy
		
		map.put("r", "raccoon");						// #5 add to original - out of range
		
		// submap.put("p", "pig");						// #6 add to copy - out of range
		System.out.println(map + " " + submap);			// #7 show final contents
		
		{a=ant, d=dog, h=horse} {d=dog}
		
		{a=ant, b=bat, d=dog, f=fish, h=horse, r=raccoon} {b=bat, d=dog, f=fish}
	
	* Если в submap положить то что выходит за границу выкинется Exception = java.lang.IllegalArgumentException: key out of range
		
		■  headSet(e, b*) 		Returns a subset ending at element e and exclusive of e
		■  headMap(k, b*) 		Returns a submap ending at key k and exclusive of key k
		■  tailSet(e, b*) 		Returns a subset starting at and inclusive of element e
		■  tailMap(k, b*) 		Returns a submap starting at and inclusive of key k
		■  subSet(s, b*, e, b*) Returns a subset starting at element s and ending just before element e
		■  subMap(s, b*, e, b*) Returns a submap starting at key s and ending just before key s
		
		Если не используется boolean то возвращается SortedSet/SortedMap
		Если используется boolean то возвращается NavigableSet/NavigableMap	
		
	* SortedMap/SortedSet не имеют pollFirst***() и pollLast***()
	
	* Если вставляется в subMap то это добавляется и в основной мап так как это ссылка на тотже мап
	
	* Типичная ситуация для экзамена когда вызывается на subMap или map - pollFirst*:
		 ■  удаляется для обоих если совпадают ключи
		 
		 {b=bat, d=dog, f=fish, h=horse, r=raccoon} {b=bat, d=dog, f=fish}
		 
		 map.pollFirstEntry();
		 
		 {d=dog, f=fish, h=horse, r=raccoon} {d=dog, f=fish}
		 
		 ■  не удаляется для обоих если не совпадают ключи
		 	{a=ant, b=bat, d=dog, f=fish, h=horse, r=raccoon} {b=bat, d=dog, f=fish}
		 	
		 	map.pollFirstEntry();
		 	
		 	{b=bat, d=dog, f=fish, h=horse, r=raccoon} {b=bat, d=dog, f=fish}
	
	* PriorityQueue - очередь с заданным приоритетом имеет конструкторы FIRST INPUT FIRST OUT
		■  PriorityQueue<E>(Collection<E> collection)
		■  PriorityQueue<E>(SortedSet<E> set)
		■  PriorityQueue<E>(PriorityQueue<E> set)
		■  PriorityQueue<E>(int initialCapacity)
		■  PriorityQueue<E>(int initialCapacity, Comparator<E>) - этим конструктором меняется приоритет
	
	* PriorityQueue - очередь с заданным приоритетом имеет следующие методы
		■  peek()		возвращает первый элемент
		■  poll()		возвращает первый элемент и удаляет его
		■  offer()		добавляет элемент в очередь
		■  element()	возвращает но не удаляет элемент в первый элемент очереди
		
Generic Types (Objectives 6.3 and 6.4)
	* На экзамене могут быть вопросы спрашивающие про Warnings
	
	* cast не нужен для Generics
	
	* javac -Xlint:unchecked - генерация warning где ошибка при компиляции
	
	* не Generic коллекция всегда возвращает Object и никакого boxing unboxing  не проиходит
		List test = new ArrayList();	
		test.add(43);
		int x = (Integer)test.get(0);    // you must cast !!
		
		List<Integer> test2 = new ArrayList<Integer>();
		test2.add(343);
		int x2 = test2.get(0);           // cast not necessary
	
	* обьявленному Generic типу должен присваиваться тот же самый тип polymorhism не работает
		List<Object> myList = new ArrayList<JButton>();  // NO!
  		List<Number> numbers = new ArrayList<Integer>(); // NO!
  		// remember that Integer is a subtype of Number
	
		// but there are fine
		List<JButton> myList = new ArrayList<JButton>(); // yes
  		List<Object> myList = new ArrayList<Object>();   // yes
  		List<Integer> myList = new ArrayList<Integer>(); // yes
	
	* Правила полиморфизма применяется только к базовым типам, а не к Generic
	 Т.е. List -> ArrayList
	 	List<JButton> myList = new ArrayList<JButton>();
	 	
	 * Для массивов polymorphism работает
	 	import java.util.*;
  		
  		class Parent { }
  		class Child extends Parent { }
  
  		public class TestPoly {
      		public static void main(String[] args) {
          		Parent[] myArray = new Child[3];  // yes
			} 
		}

	* ? extends всегда и для интерфейсов и для классов
	
	* Без wildcard ? создание нового элемента в коллекции работает
		public class PolymorphicGeneric {
		public static void main(String[] args) {
			PolymorphicGeneric polymorphicGeneric = new PolymorphicGeneric();
			
			List<Cat> cats = new ArrayList<Cat>();
			cats.add(new Cat());
			polymorphicGeneric.addAnimal(cats); // This is now OK
		}
	
		public void addAnimal(List<? extends Animal> animals) { // Yes wildcard
			animals.add(new Dog()); // This is broken ??? WTF
		}}
	
		abstract class Animal {}
		class Dog extends Animal {}
		class Cat extends Animal {}
		
		//Но
		public class PolymorphicGeneric {
		public static void main(String[] args) {
			PolymorphicGeneric polymorphicGeneric = new PolymorphicGeneric();
			
			List<Cat> cats = new ArrayList<Cat>();
			cats.add(new Cat());
			polymorphicGeneric.addAnimal(cats); // Error
		}
	
		public void addAnimal(List<? extends Animal> animals) { // No wildcard
			animals.add(new Dog()); // still OK as always
		}}
	
		abstract class Animal {}
		class Dog extends Animal {}
		class Cat extends Animal {}		
	
	* есть еще wildcard super 
	  Если добавить public void addAnimal(List<? super Dog> animals) то все будет ок
	  Данная строчка позволяет добавлять супер типы в иерархии, ну и собственно сами типы
	   	List<Animal> newanimal - ОК
	   	animals.add(new Dog()); // OK
	
	* List<?> list - позволяет передавать в метод list любых элементов
		List<JButton> buttons = new ArrayList<Jbutton>(); -  работает
		// но
		
		void doInsert(List<?> list) { //Won't compile
      	 list.add(new Dog());
    	}
	
	* List<?> foo = new ArrayList<? extends Animal>(); - ошибка компиляции
		Нельзя использовать wildcard в создании, только в присвоении
		
	* List<? super Animal> dList = new ArrayList<Dog>(); - ошибка компиляции
	 Тип должен быть Animal или выше
	 
	* В Generic объявлении метода - необходимо сначало объявить тип, а потом указать возвращаемое значение
  		public <T> void makeArrayList(T t) {} // ОК type is defined righ
  		
  		public void <T> makeArrayList(T t) {} // type is defined wrong - after return type
  		
  	* Объявление типа в конструкторе реально 
  		public class Radio {
			public <T> Radio(T t) { }  // legal constructor
		}
		
	* class X { public <X> X(X x) { } } - это все круто
	
Inner Classes
	* Inner class компилируется в отдельный class файл с <именем родителя>$<имя inner класса>
	
	* Inner class не может иметь статических методов и переменных, переменные должны быть final или сам Inner class должен быть static
	
	* Inner class имеет доступ к private переменным класса родителя
	
	* Инстанцирование должно производиться после инициализации внешнего класса
	
	* Инстанцирование внутреннего класса вне внешего имеет следующий синтаксис
		InnerClasses ic = new InnerClasses();
		InnerClasses.Inner in = ic.new Inner();
		InnerClasses.Inner in = ic.     new Inner(); // All ok
		
	* this ссылается на inner класс
	
	* для ссылки на внешний класс используется <имя_внешнего_класса>.this
		MyOuter.this
	
	* Модификаторы доступа
		■ final
		■ abstract
		■ public
		■ private
		■ protected
		■ static—but static turns it into a static nested class not an inner class 
		■ strictfp

Method-Local Inner Classes	
	* В методе можно декларировать inner класс, но извне его использовать нельзя только там
	
	* Inner классы не могут использовать локальных переменных - это приводит к ошибке компиляции
		public void innerWiredDecalre() {
			int a = 10;
			class Inner2 {
				private void go(){
					System.out.println(a); // ошибка компиляции
				}
			}
		}
	
	* Inner классы в методах не могут быть private, public, protected, transient, static
	
	* Класс в методе может помечен или abstract или final
	
	* Inner класс в статическом методе работает по тем же правилам что и статические члены: не может обращаться к нестатическим переменным
		private Inner ic = new Inner();
		public static void innerWiredDecalre() {
			final int a = 10;
			class Inner2 {
				private void go() {
					System.out.println(ic); // Ошибка компиляции
				}
			}
		}
	
Anonymous Inner Classes
	* Анонимный класс как бы наследуется от своего суперкласса
	
	* Анонимный класс обязательно должен иметь в обяъявлении <имя_класса>() {};
	
	* Анонимный класс обязательно должен заканчиваться ";" иначе это ошибка 
	
	* К анонимному классу придъявляются все теже принципы на переопределение и на полиморфизм
	
	* Созданный метод в анонимном классе не может быть вызван извне класса
	
	* Создание ананимного класса из интерфейса работает
	
	* Анонимный класс можно создать прямо в методе
		class MyWonderfulClass {
			void go() {
			  Bar b = new Bar();
			  b.doStuff(new Foo() {
		    	public void foof() {
		      		System.out.println("foofy");
		    		} // end foof method
		  		}); // end inner class def, arg, and b.doStuff stmt.
			} // end go()
		 } // end class
 
		 interface Foo {
		   void foof();
		 }
			 class Bar {
		   void doStuff(Foo f) { }
		 } 
	
  	* В вызове метода обязательно должно быть }):
		} - закрывает анонимный класс
		) - закрывает вызов метода
		; - закрывает выражение
		
Static Nested Classes
	* static inner class 
		class BigOuter {
			static class Nested { }
		}
		
	* это значит к нему есть доступ как статическому члену без ссылки на внешний класс
	
	* Инстанцирование static inner class: BigOuter.Nest n = new BigOuter.Nest();   // both class names
	
	* На экзамене самая распространенная проблема это использование стического внутреннего класса с нестатическими переменными
	
Defining, Instantiating, and Starting Threads (Objective 4.1)
	* Для экзамена необходимо знать как миниму 4 метода:
		■  start()
  		■  yield()
  		■  sleep()
  		■  run()
  		
  	* Поток можно заставить выполняться 2мя способами:
  		■ Extend the java.lang.Thread class.
		■ Implement the Runnable interface.
		
	* При наследовании Thread нужно переопределить метод run() - плохо при проектировании так как Java поддерживает только единственное наследование 
	
	* Метод run можно переопределять, но это не вызовется в новом потоке с новым методом
		class MyThread extends Thread {
			public void run() {
				System.out.println("Important job running in MyThread");
			}
			public void run(String s) {
				System.out.println("String in run is " + s);
			} }
			
	* Если класс унаследовал Thread то инстанцирование очень простое
		MyThread t = new MyThread()
		
	* Если класс имплементирует Runnable то инстанцирование будет:
		MyRunnable r = new MyRunnable(); 	// Сначала экземпляр собственного класса
		Thread t = new Thread(r);			// Затем создать экземпляр класса Thread передав ему свой runnable код

	* В случае Runnable объект можно передать многим потокам, тем самым они будут выполнять одну и туже работу
		public class TestThreads {
		     public static void main (String [] args) {
		       MyRunnable r = new MyRunnable();
		       Thread foo = new Thread(r);
		       Thread bar = new Thread(r);
		       Thread bat = new Thread(r);
		} }
	
	* Класс Thread сам по себе имплементирует Runnable
		Thread t = new Thread(new MyThread()); // такая запись легальна
		
	* Класс Thread имеет следующие конструкторы
		■ Thread()
		■ Thread(Runnable target)
		■ Thread(Runnable target, String name) 
		■ Thread(String name)
		
	* До запуска Thread находится в состоянии new
	
	* После запуска start() поток переходит в состояние alive
	
	* После завершения run() поток переходит в death
	
	* Метод isAlive() предназначен для того чтобы узнать что поток был запущен но не завершен метод run()
	
	* Запуск потока t.start()
	
	* После вызова метода  start() происходит следующее:
		■ Начинается выполнение нового потока с новым call стеком
		■ Поток переходит из состояния new в состояние runnable
		■ Когда поток получает возможность выполнится он выполняет target метод run()
		
	* На экзамене встречается следующий код
		Thread t = new Thread();
		t.run();  // Legal, but does not start a new thread
		
	* Поток имеет имя которое можнополучить вызвав метод getName() у экземпляра, но экземпляр получить можно вызвав статический метод
		Thread.currentThread()
		Потоку можно установить имя t.setName("Fred");
		
		class NameRunnable implements Runnable {
			public void run() {
				System.out.println("NameRunnable running");
	         	System.out.println("Run by " + Thread.currentThread().getName());

			} }
		public class NameThread {
			public static void main (String [] args) {
				NameRunnable nr = new NameRunnable();
				Thread t = new Thread(nr);
				t.setName("Fred");
				t.start();
			} }
		
		// Вывод NameRunnable running
  		// Run by Fred
  	
  	* Если потоку не задать имя он все равно его получит вида 
  		Thread-0
  		
  	* Если вызвать имя потока в методе main то получим:
  		public class NameThreadTwo {
	     public static void main (String [] args) {
	       System.out.println("thread is " + Thread.currentThread().getName());
		} }
		// thread is main
	
	* Если запустить несколько потоков в цикле порядок выполнения не гарантирован
	
	* start() нельзя вызвать повторно породит RuntimeException: IllegalThreadStateException
	
	* у потока можно вызвать getld() - вернет положительный long 
	
The Thread Scheduler
	* scheduler часть JVM -он управляет состоянием потока
	
	* scheduler решает какой доступный поток выполнить - доступный поток это поток который находится в состоянии runnable
	
	* Методы класса java.lang.Thread
		public static void sleep(long millis) throws InterruptedException 
		public static void yield()
		public final void join() throws InterruptedException
		public final void setPriority(int newPriority)
		
	* InterruptedException - это checked Exception и оно должно отлавливаться
	
	* Методы класса java.lang.Object
		public final void wait() throws InterruptedException 
		public final void notify()
		public final void notifyAll()

Thread States and Transitions (Objective 4.2)
	
	
	
	