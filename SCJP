Arrays
	* У массивов length это свойство
		String[] x = new String[3];
		System.out.println( x.length() ); // compiler error
	
Boxing
	* Boolean, Byte, Character from \u0000 to \u007f (127), Short and Integer from -128 to 127 They are be =
	
		Integer i1 = 10;
		Integer i2 = 10;
		i1 == i2; // True
		
		Integer i1 = 128;
		Integer i2 = 128;
		i1 == i2; // False because > 127 but equals True
	 
	 * Оболочные классы не могут быть расширены Bytes не может быть раширен до Short e.t.c
	 * При overloading и autoboxing если просходит раширение до типа то проверяется IS-A
	
	 	class WidenAndBox {
	 		static void go(Long x) { System.out.println("Long"); }
            
            public static void main(String [] args) {
                    byte b = 5;
                    go(b); // must widen then box - illegal
			} 
		}
	
	* Here's a review of the rules for overloading methods using widening, boxing, and var-args:
		■ Primitive widening uses the "smallest" method argument possible.
		■ Used individually, boxing and var-args are compatible with overloading.
		■ You CANNOT widen from one wrapper type to another. (IS-A fails.)
		■ You CANNOT widen and then box. (An int can't become a Long.)
		■ You can box and then widen. (An int can become an Object, via Integer.)
		■ You can combine var-args with either widening or boxing.
	
	* такое возможно int[][] a = {{1,2,}, {3,4}};
	
Operators
	* операторы += *= делают cast
	
	* операторы *= *= работают на выражением справа
		int a *= 3 - 2
		 Это не a = 3*a - 
		 Это не a = a*(3-2)
		 
	* instanceof null всегда false
	
	* непрямая проверка instanceof true если супер класс имплеметирует интерфейс то и потомки неявно его имплеметирует
		interface Foo { }
		class A implements Foo { }
		class B extends A { }
		...
		A a = new A();
		B b = new B();
		
	  the following are true:
		a instanceof Foo
		b instanceof A
		b instanceof Foo // implemented indirectly
		
	* Нельзя проверять через instanceof 2 разные иерархии классов это Compilation Error
		class Cat { }
		class Dog {
			public static void main(String [] args) {
				Dog d = new Dog();
				System.out.println(d instanceof Cat);
			}
		}
	
	* Массивы это объекты они проверяются True
		if (nums instanceof Object) { } // result is true
	
	* операторы * , / и % имеют приоритет выше чем + и -
	
	* скобки имеют приоритет
	
	* При конкотенации строки если поставить скобки то будет вычисляться результат
		String a = "String";
		int b = 3;
		int c = 7;
		System.out.println(a + (b + c)); // Result is String37
		System.out.println(a + (b + c)); // Result is String10
		
	* Если слева строка производится конкатенация
		String s = "123";
		s += "45";
		s += 67;
		System.out.println(s); //1234567
	
	* инкрементное значение i++ - сначала присваивается потом увеличивается
	
	* Быть осторожным с ++ -- для final переменых
		final int x = 5;
		int y = x++;
		//and produces the error:
		Test.java:4: cannot assign a value to final variable x
		int y = x++;
				^
	
	* && and || используются только с булевыми операндами
		if (5 && 6) { } // Compilation error потому что 5 и 6 int
	
	* & и | - вычисляют обе части
	
	* ^ - вычисляет обе части. Если оба операнда одинаковые то значение false

Flow, Control, Exceptions, Assertions
	* УПС
		int y = 5;
		int x = 2;
		if ((x > 3) && (y < 2) | doStuff()) //Не напечатает так как используется короткая схема
		
		if (((x > 3) && (y < 2)) | doStuff()) //Все ок 2я часть вычисляется всегда и все ОК 
		{
			System.out.println("true"); //Не напечатает так как используется короткая схема
			}
		}

		static boolean doStuff() {
			return true;
		}
	
	* в if присвоение возможно только для Boolean и boolean, остальное compilation error
		boolean boo = false;
		if (boo = true) { } //Все ок даже присвоение проходит
		
		int x = 3;
		if (x = 5) { } // Won't compile because x is not a boolean!
		
	* switch проверяет char, byte, short, int, enum 
	* в switch cast возможен
	
	* в метках switch можно использовать final переменные
		final short s =1;	
		int i = 1;
		
		switch (s) {
			case s:		All OK
				break;
		}
		
		//But,
		final short s;
		s =1;			
		int i = 1;
		
		switch (s) {
			case s:		//Compile error
				break;
		}
		
	* Одинаковые имена меток это Compile error
	
	* Если в выражение switch передать значение ниже int например byte,
		 и в метке указать значение больше значения типа то будет ошибка компиляции
	
		byte g = 2;
		switch(g) {
			case 23: 
			case 128: // 128 > разрешенных 127
		}
		
	* в switch case и : после метки обязательны
	
	* В switch char сравнивается как unicode
	
	* В switch при char работает и значение не unicode char и unicode char
				char c = '1';

		switch (c) {
			case 65535: //Legal last char
				System.out.println("1");
				break;

			case '\u0001': //Legal
				System.out.println("1"); 
				break;

			case 65536: 
				System.out.println("1"); //Compile error значение юольше разрешенного 65535 для char
				break;

			default:
				System.out.println("Default");
				break;
		}
		
		char c = '\u0001';
		
		switch (c) {
			case '\u0001':
				System.out.println("\u0001"); //Напечатается Юникод символ
				break;
		}

  Loops and Iterators (Exam Objective 2.2)
	* В блоке увеличения переменной может быть печать, анонимное создание класаса и т п
		int d = 3;
		for (int a = 1; d != 1; System.out.println("iterate")) {
			d = d - a;
		}

		int b = 3;
		for (int a = 1; b != 1; new String()) {
			b = b - a;
		}
		
		//Но
		int b = 3;
		for (int a = 1; b != 1; {new String()}) { // ошибка из за {}
			b = b - a;
		}
		
	* continue - используется только в циклах
	
	* break - используется в циклах и switch
	
	* Метка должна предворять цикл или иметь {} в случае наличия выражение перед ней
	
		label: //All OK 
			for (int i = 0; i < args.length; i++) {
				System.out.println("InLOOP");
				break label;
			}

		// Но ошибка если что то есть
		label: //Compile error
			System.out.println("Before Loop");
			for (int i = 0; i < args.length; i++) {
				System.out.println("InLOOP");
				break label;
			}
			
		// Но нет ошибки если есть {}
		label: { //OK
			System.out.println("Before Loop");
			for (int i = 0; i < args.length; i++) {
				System.out.println("InLOOP");
				break label;
			}
		}
		
Handling Exceptions (Exam Objectives 2.4 and 2.5)
	* Иерархия классов Exception
		Object
		  |
	   Throwable
	    |	   |
	 Error    ____Exception______
	 |		|					|
Others... RuntimeException	 Others... 

	* Если в коде выбрасывается исключение и оно checked то будет compile error
		
		//Fail IOException нужно задекларировать
		public void doStuff() {
			try {
				// risky IO things
			} catch(IOException ex) {
				// can't handle it
				throw ex; // Can't throw it unless you declare it
			}
		}
	
	* finally может не вызваться если в try или catch вызван System.exit()  
		
Common Exceptions and Errors (Exam Objective 2.6)
	*Throw JVM
		ArrayIndexOutOfBoundsException
		ClassCastException
		NullPointerException
		ExceptionInInitializerError
		StackOverflowError
		NoClassDefFoundError
	
	*throw Programmatically
		IllegalArgumentException
		IllegalStateException
		NumberFormatException
		AssertionError

Working with the Assertion Mechanism  (Exam Objective 2.3)
	*Валидное использование Assertion
		int x = 1;
		boolean b = true;
		int aReturn() { return 1; }
		
		assert(x == 1);
		assert(b);
		assert true;
		assert(x == 1) : x;
		assert(x == 1) : aReturn();
		assert(x == 1) : new ValidAssert();
		
	*Невалидное использование Assertion
		void noReturn() { }
		
		assert(x = 1); // none of these are booleans
		assert(x);
		assert 0;
		assert(x == 1) : ; // none of these return a value
		assert(x == 1) : noReturn();
		assert(x == 1) : ValidAssert va;
		
	* До версии 1.4 слово assert можно использовать как идентификатор
		int assert = getInitialValue();
		if (assert == getActualResult()) {
			// do something
		}
	  
	  Если использовать компиляцию для 1.6 будет ошибка, 
	  но можно сделать javac -source 1.3 OldCode.java - все ок хотя если использовать assert как ключевое слово то это ошибка
	  
	 * 2 опции для включения компиляторов 5,6 
	 	-source 1.6 or -source 6
	 	-source 1.5 or -source 5
	 
	 * Компиляция под разные версии JVM
	 	javac -source 1.3 TestAsserts.java
	 	javac -source 1.4 TestAsserts.java
	 	javac -source 1.5 TestAsserts.java
	 	javac -source 5 TestAsserts.java
	 	javac -source 1.6 TestAsserts.java
	 	javac -source 6 TestAsserts.java
	 
	 * Включение assertion в runtime
	 	java -ea com.pack.TestClass
	 	java -enableassertions com.pack.TestClass
	 	
	 * Выключение assertion в runtime
	 	java -da com.pack.TestClass
	 	java -disableassertions com.pack.TestClass
	 	
	 * Частичное исключение классов
	 	java -ea -da:com.geeksanonymous.Foo Test
	 	
	 * Частичное исключение пакетов
	 	java -ea -da:com.geeksanonymous...
	 	
	 * Tricky assertion
	 	java -ea -dsa Enable assertions in general, but disable assertions in system classes.

Using Assertions Appropriately (По конвеции Sun)
	 * Inappropriate использовать assertion для валидации аргументов в public методах
		 public void doMore(int x) {
			assert (x > 0);
			// do things with x
		}
	 * Inappropriate использовать assertion для валидации аргументов командной строки
	 * Inappropriate использовать assertion для изменения логики работы программы, при вызове assertion и без него логика остается таже
	 	public void doStuff() {
			assert (modifyThings());
			// continues on
		}
		
		public boolean modifyThings() {
			y = x++;
			return true;
		}
	 
	 * Appropriate использовать assertion для валидации аргументов в private методах
	 	private void doMore(int x) {
			assert (x > 0);
			// do things with x
		}
	
	* Appropriate использовать assertion для кода который точно никогда не выполнится даже в public методах
		switch(x) {
			case 1: y = 3; break;
			case 2: y = 9; break;
			case 3: y = 27; break;
			default: assert false; // we're never supposed to get here!
		}

Strings
	* Создание строк генерирует разное число объектов
		String s = "abc"; // creates one String object and one 
							// reference variable
		// В этом случае "abc" отправляется в pool и создается ссылка s 
		
		String s = new String("abc"); // creates two objects, 
										// and one reference variable
		//В этом случае создается объект в обычной памяти, создается ссылка, а также "abc" помещается в пул				
		
	* Методы которые встречаются на экзамене
		■  public charAt()Returns the character located at the specified index
		■  public concat()Appends one String to the end of another ( "+" also works)
		■  public equalsIgnoreCase() Determines the equality of two Strings, ignoring case
		■  public length()Returns the number of characters in a String
		■  public replace()Replaces occurrences of a character with a new character
		■  public substring()Returns a part of a String
		■  public toLowerCase()Returns a String with uppercase characters converted
		■  public toString()Returns the value of a String
		■  public toUpperCase()Returns a String with lowercase characters converted
		■  public trim() Removes whitespace from the ends of a String
	
	* У строк length это мето
		String x = "test";
		System.out.println( x.length ); // compiler error
		
	* substring() в Java хитрый
		String x = "0123456789"
		System.out.println( x.substring(5) ); // output is "56789"
		System.out.println( x.substring(5, 8)); // output is "567"
		//Во втором случае с 5го индекса и до 8го индекса или до 7го включительно
		
StringBuffer, StringBuilder
	* Методы которые встречаются на экзамене для StringBuffer (для StringBuilder они not sychronized)
		■  public synchronized StringBuffer append(String s) - This method will take many dif-ferent arguments, including boolean, char, double, float, int, long, and other
			StringBuffer sb = new StringBuffer("set ");
			sb.append("point");
			
		■  public StringBuilder delete(int start, int end)
			StringBuilder sb = new StringBuilder("0123456789");
			System.out.println(sb.delete(4,6)); // output is "01236789"
			
		■  public StringBuilder insert(int offset, String s)
			StringBuilder sb = new StringBuilder("01234567");
			sb.insert(4, "---");
			System.out.println( sb ); // output is "0123---4567"
			
		■  public synchronized StringBuffer reverse()
			StringBuffer s = new StringBuffer("A man a plan a canal Panama");
			sb.reverse();
			System.out.println(sb); // output: "amanaP lanac a nalp a nam A"
			
		■  public String toString()

File Navigation and I/O (Exam Objective 3.2)
	* I/O Классы для экзамена
		■  File - абстрактное представление файла и директорий с путями до них 
		■  FileReader - класс для чтения символа из файла. Метод read() - читает один символ. Читает потоки символов. Фиксированный набор символов.
			FileReader - обычно оборачивают Высокоуровнемы классами Reader, таким как BufferedReaders - который улучшает производительность засчет буфферизации 
			и предоставляет более удобные способы для работы с данными
		
		■  BufferedReader - lower-level Reader. В сравнении с FileReader считывает относительно большие куски данных из файла и помещает в буфер.
			Когда запашиватся символ или строка данных они достаются из буфера - это уменьшает количество обращений к файлу тем самым увеличивается
			производительность.
			Кроме того BufferedReader предоставляет более удобные, по сравнению с FileReader методы например readLine() - считывает следующую строку из файла 
		
		■  FileWriter - используется для записи символа в файл. Его методы write() позволяют записывать: символ(ы), или строки в файл.
			FileWriter обычно оборачивают Высокоуровнемы классами Writer таким как BufferedWriter или PrintWriter, которые предоставляю лучшую производительность 
			и более удобные методы для записи данных в файл.
			
		■  BufferedWriter - используется для высокоуровнего представления классов таких как FileWriter. В сравнении с FileWrite записывает относительно большие куски данных
			 порциями, тем самым уменьшая количество тяжелых операций записи.
			 BufferedWriter предоставляет удобные методы для записи в файл, например newLine() - автоматически создает платформенно специфичный символ новой строки
			 
		■  PrintWriter - самый мощный и доработанный класс
		
		■  Console - класс для работы с консолью

	* Обязательно нужен import java.io.*;
	* new File("fileWrite1.txt") не создает еще файл
		newFile = file.createNewFile() - создает файл или ссылку на существующий возвращает boolean
		System.out.println(file.exists());  // look for a real file
		
	* createNewFile() создает новый файл только если он не существует
	
	* FileWriter - нужно делать flush() и close()
	
	* FileWriter fw = new FileWriter(file); // Физически создает файл
	
	* FileReader - read(char [] buffer), обязательно нужно закрывать
	
	* File - имеет метод по созданию директории mkDir()
	
	* File - можно привезать и к директории File(File директория, String имя_файла)
	
	* Если не создать директорию вызвав метод но передать в конструктор то будет ошибка java.io.IOException: No such file or directory
	
	* метод delete() у класса File не может удалить директорию если она не пустая
	
	* renameTo() - выбросит NullPointerEception если передать null в имя нового файла
	
	* Для поиска файла используется метод String [] search()
		String[] files = new String[100];
		File search = new File("searchThis");
		files = search.list();
		
java.io.Console Class
	* System.console() - возвращает ссылку на физическую консоль, невозможно использовать если нет доступа

	* char[] readPassword - возвращает набор символов чтобы не быть помещенным в StringPool
	
	* Получение консоли Console c = System.console();
	
	* pw = c.readPassword("%s", "pw: "); - 1й параметр формат 2й приветствие
	
	* c.format("%c", char_) - форматированный вывод
	
Serialization (Exam Objective 3.3)
	* ObjectOutputStream.writeObject() // serialize and write
	
	* ObjectInputStream.readObject() // read and deserialize
	
	* Обязательно должен быть имплеменирован интерфейс Serializable
	
	* Все классы которые ссылаются на сериализованный объект должны быть Serializable
	
	* Если нет возможности сохранить класс то можно пометить его transient
	
	* readObject бросает ClassNotFoundException
	
	* Для того чтобы обойти ограничение несериализуемого объекта можно создать 2 метода для управления процессом сериализации:
		private void writeObject(ObjectOutputStream os){
			// throws IOException { // 1
			try {
				os.defaultWriteObject();// 2
				os.writeInt(theCollar.getCollarSize()); // 3 
			} catch (Exception e) { e.printStackTrace(); }
		}
		
		private void readObject(ObjectInputStream is) {
			// throws IOException, ClassNotFoundException { // 4 
			try {
				is.defaultReadObject();// 5 
				theCollar = new Collar(is.readInt()); // 6
			} catch (Exception e) { e.printStackTrace(); }
		}
	
	* Порядок чтения должен быть таким же как и при записи в случае записи дополнительного кода : os.writeInt(int)
	
	* При сериализации коллекций и массивов - все их элементы должны быть Serializarble
	
	* Object не Serializable
	
	* static не сериализуются потому что принадлежат классу
	
Inheritance and Serialization
	* В случае если супер класс не Serializable, а потомок да то при восстановление унаследованная часть будет переинициализирована
		
		!!!!!Конструктор запустится заново!!!
		
		class Animal {
			public String name;
		}
		class Dog extends Animal implements Serializable {
			// the rest of the Dog code
		}
	
Dates, Numbers, and Currency (Exam Objective 3.4)
	* На экзамене необходимо понимать следующие классы
		■  java.util.Date
		■  java.util.Calendar
		■  java.util.Locale
		■  java.text.DateFormat
		■  java.text.NumberFormat
	
	* Типичные операции
		■  Получить текущую дату и время
			Date d = new Date();
			String s = d.toString();
		■  Получить объект позволяющий выполнять операции с датой и временем в вашей локале
			Calendar c = Calendar.getInstance();
			c.add(...)
			c.rool(...)
		■  Получить объект позволяющий выполнять операции с датой и временем в различной локале
			Locale loc = new Locale(language);or
			Locale loc = new Locale(language, country);
			
			Calendar c = Calendar.getInstance(loc);
			c.add(...)
			c.rool(...)
		■  Получить объект позволяющий выполнять операции с датой и временем в различной локале и применить форматировый вывод в разных стилях
			Calendar c = Calendar.getInstance();
			Locale loc = new Locale(...);
			Date d = c.getTime();
			DateFormat df = DateFormat.getDateInstance(style, loc);
			String s = df.format(d);
		■  Получить объект позволяющий выполнять форматирование цифр и валют в различных локалях
			Locale loc = new Locale(...);
			NumberFormat nf = NumberFormat.getInstance(loc);
				-or- NumberFormat nf = NumberFormat.getCurrencyInstance(loc);
			String s = nf.format(someNumber);
	
	* Calendar зависит от локали - Calendar.SUNDAY == c.getFirstDayOfWeek() - проверка дня недели в Англии это Sunday в России Monday
	
	* Calendar абстрактный класс, но имеет статический инициализатор который инстанцирует календарь
	
	* Calendar.getInstance() - инициализируется текущим временем
	
	* В календаре месяц при установке начинается с 0
		Calendar c = Calendar.getInstance();
		c.set(2010, 11, 14); // December 14, 2010
	
	* calendar.add(field, amount) - добавляет значение если не указать отрицательное число
	
	* roll - метод для увеличения или умньшения части даты, но не позволяет перейти границу значения
		// assume c is October 8, 2001
		c.roll(Calendar.MONTH, 9); // notice the year in the output
		Date d4 = c.getTime();
		System.out.println("new date " + d4.toString() ); //new date Fri Jul 08 19:46:40 MDT 2001
	
	* DateFormat - абстрактный с 
		DateFormat.getInstance();                      //9/8/01 7:46 PM
		DateFormat.getDateInstance();                  //Sep 8, 2001
		DateFormat.getDateInstance(DateFormat.SHORT);  //9/8/01
		DateFormat.getDateInstance(DateFormat.MEDIUM); //Sep 8, 2001
		DateFormat.getDateInstance(DateFormat.LONG);   //September 8, 2001
		DateFormat.getDateInstance(DateFormat.FULL);   //Saturday, September 8, 2001
		
		String df.format(дата)
		Date df.parse(String)
	
	* DateFormat и NumberFormat - не меняют локали в runtime это ошибка компиляции 
	
	* Класс Locale 2 конструктора и 1 статический инициализатор
		Locale defaultLocale = Locale.getDefault();
		Locale locPT = new Locale("it"); // Italian
		Locale locBR = new Locale("it", "CH"); // Switzerland
	
	* Класс Locale методы
		Locale locBR = new Locale("pt", "BR"); // Brazil
		System.out.println("def " + locBR.getDisplayCountry());      //Brasil
		System.out.println("loc " + locBR.getDisplayCountry(locBR)); //Brasil
		
	* Класс NumberFormat абстрактный со статическими инициализаторами
		Locale locFR = new Locale("fr");
		NumberFormat.getInstance();				//123.457
		NumberFormat.getInstance(locFR);		//123.457
		NumberFormat.getCurrencyInstance();		//$123.46
		NumberFormat.getCurrencyInstance(loc);	//123,46 ?
		
		Вызвав format(число)	
	
	* По умолчанию количество цифр после запятой 3
		float f = 10.1126f;
		NumberFormat fn = NumberFormat.getInstance();
		System.out.println(fn.getMaximumFractionDigits());	//Выведет 3
		System.out.print(nf.format(f1) + " "); 				//Выведет 10,113
		// Можно расширить
		fn.setMaximumFractionDigits(5);
		System.out.print(nf.format(f1) + " "); 				//Выведет 10,1126
		fn.parse("1234.567") // Бросает ParseException и Возвращает Number - который абстрактный и реализуют оболочки примитивных типов
		fn.setParseIntegerOnly(true); //Задает парсинг только integer
		
		fn.parse("1234.567") //Выводит 1234
		
Parsing, Tokenizing, and Formatting (Exam Objective 3.5)
	*	